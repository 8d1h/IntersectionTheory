var documenterSearchIndex = {"docs":
[{"location":"constructors/","page":"Constructors","title":"Constructors","text":"CurrentModule = IntersectionTheory\nDocTestSetup = quote\n  using IntersectionTheory\nend","category":"page"},{"location":"constructors/","page":"Constructors","title":"Constructors","text":"using IntersectionTheory","category":"page"},{"location":"constructors/#Constructors","page":"Constructors","title":"Constructors","text":"","category":"section"},{"location":"constructors/#Generic-varieties","page":"Constructors","title":"Generic varieties","text":"","category":"section"},{"location":"constructors/","page":"Constructors","title":"Constructors","text":"The following constructors are available for building generic varieties.","category":"page"},{"location":"constructors/","page":"Constructors","title":"Constructors","text":"variety","category":"page"},{"location":"constructors/#IntersectionTheory.variety","page":"Constructors","title":"IntersectionTheory.variety","text":"variety(n::Int, symbols::Vector{String}, degs::Vector{Int})\n\nConstruct a generic variety of dimension n with some classes in given degrees.\n\nReturn the variety and the list of classes.\n\n\n\nvariety(n::Int, bundles::Vector{Pair{Int, T}}) where T\n\nConstruct a generic variety of dimension n with some bundles of given ranks.\n\nReturn the variety and the list of bundles.\n\n\n\nvariety(n::Int)\n\nConstruct a generic variety of dimension n and define its tangent bundle.\n\nReturn the variety.\n\n\n\n","category":"function"},{"location":"constructors/#Examples","page":"Constructors","title":"Examples","text":"","category":"section"},{"location":"constructors/","page":"Constructors","title":"Constructors","text":"X = variety(2, [\"h\", \"c1\", \"c2\"], [1, 1, 2])\nY, (E,) = variety(2, [3 => \"c\"])\nchern(E)\nZ = variety(2)\nchern(tangent_bundle(Z))","category":"page"},{"location":"constructors/","page":"Constructors","title":"Constructors","text":"note: Note\nThe generic varieties are created without any relations by default. There are of course trivial relations due to dimension (i.e., all classes with codimension larger than the dimension of the variety must be zero). Use trim! on the Chow ring will add these relations and make the quotient ring Artinian. Then we will be able to compute basis, betti, and related things.","category":"page"},{"location":"constructors/#Projective-spaces,-Grassmannians,-flag-varieties","page":"Constructors","title":"Projective spaces, Grassmannians, flag varieties","text":"","category":"section"},{"location":"constructors/","page":"Constructors","title":"Constructors","text":"The following constructors are available.","category":"page"},{"location":"constructors/","page":"Constructors","title":"Constructors","text":"point\nproj(n::Int)\ngrassmannian(k::Int, n::Int; bott::Bool=false)\nflag(dims::Int...; bott::Bool=false)","category":"page"},{"location":"constructors/#IntersectionTheory.point","page":"Constructors","title":"IntersectionTheory.point","text":"point()\n\nConstruct a point as an abstract variety.\n\n\n\n","category":"function"},{"location":"constructors/#IntersectionTheory.proj-Tuple{Int64}","page":"Constructors","title":"IntersectionTheory.proj","text":"proj(n::Int)\n\nConstruct an abstract projective space of dimension n, parametrizing 1-dimensional subspaces of a vector space of dimension n+1.\n\n\n\n","category":"method"},{"location":"constructors/#IntersectionTheory.grassmannian-Tuple{Int64, Int64}","page":"Constructors","title":"IntersectionTheory.grassmannian","text":"grassmannian(k::Int, n::Int; bott::Bool=false)\n\nConstruct an abstract Grassmannian mathrmGr(k n), parametrizing k-dimensional subspaces of an n-dimensional vector space.\n\nUse the argument bott=true to construct the Grassmannian as a TnVariety for computing integrals using Bott's formula.\n\n\n\n","category":"method"},{"location":"constructors/#IntersectionTheory.flag-Tuple{Vararg{Int64, N} where N}","page":"Constructors","title":"IntersectionTheory.flag","text":"flag(dims::Int...; bott::Bool=false)\nflag(dims::Vector{Int}; bott::Bool=false)\n\nConstruct an abstract flag variety mathrmFl(d_1dotsd_k), parametrizing flags of subspaces V_d_1subset V_d_2subsetcdotssubset V_d_k=V.\n\nUse the argument bott=true to construct the flag variety as a TnVariety for computing integrals using Bott's formula.\n\n\n\n","category":"method"},{"location":"constructors/","page":"Constructors","title":"Constructors","text":"note: Note\nMathematically mathrmFl(k n) is exactly the same as mathrmGr(k n). The difference is that the Chow ring returned by grassmannian uses only k generators instead of n.","category":"page"},{"location":"constructors/#Examples-2","page":"Constructors","title":"Examples","text":"","category":"section"},{"location":"constructors/","page":"Constructors","title":"Constructors","text":"proj(2)\ngrassmannian(2, 4)\ngrassmannian(2, 4, bott=true)\nflag(1, 3, 5)\nflag([1, 3, 5])","category":"page"},{"location":"constructors/","page":"Constructors","title":"Constructors","text":"For all the above constructors, the base argument can be used to introduce parameters using Singular's FunctionField.","category":"page"},{"location":"constructors/","page":"Constructors","title":"Constructors","text":"F, (k,) = FunctionField(Singular.QQ, [\"k\"]);\nP2 = proj(2, base=F);\nchi(OO(P2, k))\nsymmetric_power(k, 2OO(P2))","category":"page"},{"location":"constructors/#Projective-bundles,-relative-flag-varieties","page":"Constructors","title":"Projective bundles, relative flag varieties","text":"","category":"section"},{"location":"constructors/","page":"Constructors","title":"Constructors","text":"In the relative setting, the following constructors are available.","category":"page"},{"location":"constructors/","page":"Constructors","title":"Constructors","text":"proj(F::AbsBundle)\nflag(d::Int, F::AbsBundle)","category":"page"},{"location":"constructors/#IntersectionTheory.proj-Tuple{IntersectionTheory.AbsBundle}","page":"Constructors","title":"IntersectionTheory.proj","text":"proj(F::AbsBundle)\n\nConstruct the projectivization of a bundle F, parametrizing 1-dimensional subspaces.\n\n\n\n","category":"method"},{"location":"constructors/#IntersectionTheory.flag-Tuple{Int64, IntersectionTheory.AbsBundle}","page":"Constructors","title":"IntersectionTheory.flag","text":"flag(d::Int, F::AbsBundle)\nflag(dims::Vector{Int}, F::AbsBundle)\n\nConstruct the relative flag variety of a bundle F, parametrizing flags of subspaces V_d_1subset V_d_2subsetcdotssubset V_d_k. The last dimension (i.e., the rank of F) can be omitted.\n\n\n\n","category":"method"},{"location":"constructors/#Moduli-spaces-of-matrices,-parameter-spaces-of-twisted-cubics","page":"Constructors","title":"Moduli spaces of matrices, parameter spaces of twisted cubics","text":"","category":"section"},{"location":"constructors/","page":"Constructors","title":"Constructors","text":"matrix_moduli\ntwisted_cubics\ntwisted_cubics_on_quintic_threefold\ntwisted_cubics_on_cubic_fourfold","category":"page"},{"location":"constructors/#IntersectionTheory.matrix_moduli","page":"Constructors","title":"IntersectionTheory.matrix_moduli","text":"matrix_moduli(q::Int, m::Int, n::Int)\nmatrix_moduli(V::AbsBundle, m::Int, n::Int)\n\nConstruct the moduli space N(qmn) of ntimes m matrices of linear forms on a q-dimensional vector space, or relative to a rank-q vector bundle V.\n\n\n\n","category":"function"},{"location":"constructors/#IntersectionTheory.twisted_cubics","page":"Constructors","title":"IntersectionTheory.twisted_cubics","text":"twisted_cubics()\ntwisted_cubics(V::AbsBundle)\n\nConstruct the parameter space H of twisted cubics in mathbf P^3, or relative to a rank-4 vector bundle V, as the blowup of the matrix moduli space X along iIhookrightarrow X.\n\nReturn the parameter space H and the exceptional divisor Y.\n\n\n\n","category":"function"},{"location":"constructors/#IntersectionTheory.twisted_cubics_on_quintic_threefold","page":"Constructors","title":"IntersectionTheory.twisted_cubics_on_quintic_threefold","text":"twisted_cubics_on_quintic_threefold()\n\nCompute the number of twisted cubics on a generic quintic threefold.\n\n\n\n","category":"function"},{"location":"constructors/#IntersectionTheory.twisted_cubics_on_cubic_fourfold","page":"Constructors","title":"IntersectionTheory.twisted_cubics_on_cubic_fourfold","text":"twisted_cubics_on_cubic_fourfold()\n\nCompute the Euler number of the LLSvS eightfold Z associated to a cubic fourfold.\n\nUse the argument M3=true to return the 10-dimensional parameter space M_3 of twisted cubics on a cubic fourfold. The Euler number of Z can then be obtained as e(Z) = frac13e(M_3)-81.\n\n\n\n","category":"function"},{"location":"constructors/","page":"Constructors","title":"Constructors","text":"warning: Warning\nThe various twisted_cubics functions produce the same result as Chow, however I cannot reproduce the intersection numbers found by Schubert. More investigation is needed.","category":"page"},{"location":"constructors/#Others","page":"Constructors","title":"Others","text":"","category":"section"},{"location":"constructors/","page":"Constructors","title":"Constructors","text":"linear_subspaces_on_hypersurface","category":"page"},{"location":"constructors/#IntersectionTheory.linear_subspaces_on_hypersurface","page":"Constructors","title":"IntersectionTheory.linear_subspaces_on_hypersurface","text":"linear_subspaces_on_hypersurface(k::Int, d::Int)\n\nCompute the number of k-dimensional subspaces on a generic degree-d hypersurface in a projective space of dimension n=frac1k+1binomd+kd+k.\n\nThe computation uses Bott's formula by default. Use the argument bott=false to switch to Schubert calculus.\n\n\n\n","category":"function"},{"location":"constructors/#Examples-3","page":"Constructors","title":"Examples","text":"","category":"section"},{"location":"constructors/","page":"Constructors","title":"Constructors","text":"IntersectionTheory.linear_subspaces_on_hypersurface(1, 3)","category":"page"},{"location":"varieties/","page":"Varieties","title":"Varieties","text":"CurrentModule = IntersectionTheory\nDocTestSetup = quote\n  using IntersectionTheory\nend","category":"page"},{"location":"varieties/","page":"Varieties","title":"Varieties","text":"using IntersectionTheory","category":"page"},{"location":"varieties/#Varieties","page":"Varieties","title":"Varieties","text":"","category":"section"},{"location":"varieties/#Basic-invariants","page":"Varieties","title":"Basic invariants","text":"","category":"section"},{"location":"varieties/","page":"Varieties","title":"Varieties","text":"degree\neuler\nhilbert_polynomial\nsignature","category":"page"},{"location":"varieties/#IntersectionTheory.degree","page":"Varieties","title":"IntersectionTheory.degree","text":"degree(X::AbsVariety)\n\nCompute the degree of X with respect to its polarization.\n\n\n\n","category":"function"},{"location":"varieties/#IntersectionTheory.euler","page":"Varieties","title":"IntersectionTheory.euler","text":"euler(X::AbsVariety)\neuler(X::TnVariety)\n\nCompute the Euler number of a variety X.\n\n\n\n","category":"function"},{"location":"varieties/#IntersectionTheory.hilbert_polynomial","page":"Varieties","title":"IntersectionTheory.hilbert_polynomial","text":"hilbert_polynomial(F::AbsBundle)\nhilbert_polynomial(X::AbsVariety)\n\nCompute the Hilbert polynomial of a bundle F or the Hilbert polynomial of X itself, with respect to the polarization mathcal O_X(1) on X.\n\n\n\n","category":"function"},{"location":"varieties/#IntersectionTheory.signature","page":"Varieties","title":"IntersectionTheory.signature","text":"signature(X::AbsVariety)\n\nCompute the signature of a variety X of even dimension.\n\n\n\n","category":"function"},{"location":"varieties/#Examples","page":"Varieties","title":"Examples","text":"","category":"section"},{"location":"varieties/","page":"Varieties","title":"Varieties","text":"degree(grassmannian(2, 4))\neuler(grassmannian(2, 4))\nhilbert_polynomial(proj(3))\nsignature(complete_intersection(proj(3), 4)) # signature of a K3 surface","category":"page"},{"location":"varieties/#Characteristic-classes","page":"Varieties","title":"Characteristic classes","text":"","category":"section"},{"location":"varieties/","page":"Varieties","title":"Varieties","text":"By common abuse of notations, the Chern/Todd/... class of a variety will mean the Chern/Todd/... class of its tangent bundle.","category":"page"},{"location":"varieties/","page":"Varieties","title":"Varieties","text":"chern(X::AbsVariety)\nchern(k::Int, X::AbsVariety)\nchern_number\nchern_numbers\ntodd(X::AbsVariety)\npontryagin(X::AbsVariety)\npontryagin(k::Int, X::AbsVariety)\na_hat_genus(X::AbsVariety)\na_hat_genus(k::Int, X::AbsVariety)\nl_genus(X::AbsVariety)\nl_genus(k::Int, X::AbsVariety)","category":"page"},{"location":"varieties/#IntersectionTheory.chern-Tuple{IntersectionTheory.AbsVariety}","page":"Varieties","title":"IntersectionTheory.chern","text":"chern(X::AbsVariety)\nchern(X::TnVariety)\n\nCompute the total Chern class of the tangent bundle of X.\n\n\n\n","category":"method"},{"location":"varieties/#IntersectionTheory.chern-Tuple{Int64, IntersectionTheory.AbsVariety}","page":"Varieties","title":"IntersectionTheory.chern","text":"chern(k::Int, X::AbsVariety)\nchern(k::Int, X::TnVariety)\n\nCompute the k-th Chern class of the tangent bundle of X.\n\n\n\n","category":"method"},{"location":"varieties/#IntersectionTheory.chern_number","page":"Varieties","title":"IntersectionTheory.chern_number","text":"chern_number(X::AbsVariety, λ::Int...)\nchern_number(X::AbsVariety, λ::Vector{Int})\nchern_number(X::AbsVariety, λ::Partition)\n\nCompute the Chern number c_lambda (X)=int_X c_lambda_1(X)cdots c_lambda_k(X), where lambda=(lambda_1dotslambda_k) is a partition of the dimension of X.\n\n\n\n","category":"function"},{"location":"varieties/#IntersectionTheory.chern_numbers","page":"Varieties","title":"IntersectionTheory.chern_numbers","text":"chern_numbers(X::AbsVariety)\n\nCompute all the Chern numbers of X as a list of pairs lambdaRightarrow c_lambda(X).\n\n\n\n","category":"function"},{"location":"varieties/#IntersectionTheory.todd-Tuple{IntersectionTheory.AbsVariety}","page":"Varieties","title":"IntersectionTheory.todd","text":"todd(X::AbsVariety)\n\nCompute the Todd class of the tangent bundle of X.\n\n\n\n","category":"method"},{"location":"varieties/#IntersectionTheory.pontryagin-Tuple{IntersectionTheory.AbsVariety}","page":"Varieties","title":"IntersectionTheory.pontryagin","text":"pontryagin(X::AbsVariety)\n\nCompute the total Pontryagin class of the tangent bundle of X.\n\n\n\n","category":"method"},{"location":"varieties/#IntersectionTheory.pontryagin-Tuple{Int64, IntersectionTheory.AbsVariety}","page":"Varieties","title":"IntersectionTheory.pontryagin","text":"pontryagin(k::Int, X::AbsVariety)\n\nCompute the k-th Pontryagin class of the tangent bundle of X.\n\n\n\n","category":"method"},{"location":"varieties/#IntersectionTheory.a_hat_genus-Tuple{IntersectionTheory.AbsVariety}","page":"Varieties","title":"IntersectionTheory.a_hat_genus","text":"a_hat_genus(X::AbsVariety)\n\nCompute the top hat A genus of a variety X of even dimension.\n\n\n\n","category":"method"},{"location":"varieties/#IntersectionTheory.a_hat_genus-Tuple{Int64, IntersectionTheory.AbsVariety}","page":"Varieties","title":"IntersectionTheory.a_hat_genus","text":"a_hat_genus(k::Int, X::AbsVariety)\n\nCompute the k-th hat A genus of a variety X.\n\n\n\n","category":"method"},{"location":"varieties/#IntersectionTheory.l_genus-Tuple{IntersectionTheory.AbsVariety}","page":"Varieties","title":"IntersectionTheory.l_genus","text":"l_genus(X::AbsVariety)\n\nCompute the top L genus of a variety X of even dimension.\n\n\n\n","category":"method"},{"location":"varieties/#IntersectionTheory.l_genus-Tuple{Int64, IntersectionTheory.AbsVariety}","page":"Varieties","title":"IntersectionTheory.l_genus","text":"l_genus(k::Int, X::AbsVariety)\n\nCompute the k-th L genus of a variety X.\n\n\n\n","category":"method"},{"location":"varieties/","page":"Varieties","title":"Varieties","text":"We also have the following functions for producing generic formulae.","category":"page"},{"location":"varieties/","page":"Varieties","title":"Varieties","text":"todd(n::Int)\na_hat_genus(n::Int)\nl_genus(n::Int)","category":"page"},{"location":"varieties/#IntersectionTheory.todd-Tuple{Int64}","page":"Varieties","title":"IntersectionTheory.todd","text":"todd(n::Int)\n\nCompute the (generic) n-th Todd genus.\n\n\n\n","category":"method"},{"location":"varieties/#IntersectionTheory.a_hat_genus-Tuple{Int64}","page":"Varieties","title":"IntersectionTheory.a_hat_genus","text":"a_hat_genus(n::Int)\n\nCompute the (generic) n-th hat A genus.\n\n\n\n","category":"method"},{"location":"varieties/#IntersectionTheory.l_genus-Tuple{Int64}","page":"Varieties","title":"IntersectionTheory.l_genus","text":"l_genus(n::Int)\n\nCompute the (generic) n-th L genus.\n\n\n\n","category":"method"},{"location":"varieties/#Examples-2","page":"Varieties","title":"Examples","text":"","category":"section"},{"location":"varieties/","page":"Varieties","title":"Varieties","text":"chern(proj(2))\ntodd(proj(2))\npontryagin(proj(2))\nchern_number(proj(3), [2,1])\nchern_numbers(proj(3))\nl_genus(proj(2))\na_hat_genus(proj(2))","category":"page"},{"location":"varieties/","page":"Varieties","title":"Varieties","text":"todd(2)\na_hat_genus(2)\nl_genus(2)","category":"page"},{"location":"varieties/#Chow-ring","page":"Varieties","title":"Chow ring","text":"","category":"section"},{"location":"varieties/","page":"Varieties","title":"Varieties","text":"basis\nbetti\nintegral\ndual_basis\nintersection_matrix","category":"page"},{"location":"varieties/#AbstractAlgebra.Generic.basis","page":"Varieties","title":"AbstractAlgebra.Generic.basis","text":"basis(X::AbsVariety)\n\nReturn an additive basis of the Chow ring of X, grouped by increasing degree (i.e., increasing codimension).\n\n\n\nbasis(k::Int, X::AbsVariety)\n\nReturn an additive basis of the Chow ring of X in codimension k.\n\n\n\n","category":"function"},{"location":"varieties/#Singular.betti","page":"Varieties","title":"Singular.betti","text":"betti(X::AbsVariety)\n\nReturn the Betti numbers of the Chow ring of X. Note that these are not necessarily equal to the usual Betti numbers, i.e., the dimensions of (co)homologies.\n\n\n\n","category":"function"},{"location":"varieties/#AbstractAlgebra.Generic.integral","page":"Varieties","title":"AbstractAlgebra.Generic.integral","text":"integral(x::ChRingElem)\n\nCompute the integral of a Chow ring element.\n\nIf the variety X has a (unique) point class X.point, the integral will be a number (an fmpq or a function field element). Otherwise the 0-dimensional part of x is returned.\n\n\n\n","category":"function"},{"location":"varieties/#IntersectionTheory.dual_basis","page":"Varieties","title":"IntersectionTheory.dual_basis","text":"dual_basis(k::Int, X::AbsVariety)\n\nCompute the dual basis of the additive basis in codimension k given by basis(k, X) (the returned elements are therefore in codimension dim X-k).\n\n\n\ndual_basis(X::AbsVariety)\n\nCompute the dual basis with respect to the additive basis given by basis(X), grouped by decreasing degree (i.e., decreasing codimension).\n\n\n\n","category":"function"},{"location":"varieties/#IntersectionTheory.intersection_matrix","page":"Varieties","title":"IntersectionTheory.intersection_matrix","text":"intersection_matrix(a::Vector)\nintersection_matrix(a::Vector, b::Vector)\nintersection_matrix(X::AbsVariety)\n\nCompute the intersection matrix among entries of a vector a of Chow ring elements, or between two vectors a and b. For a variety X, this computes the intersection matrix of the additive basis given by basis(X).\n\nReturn a Nemo.fmpq_mat if possible, or a Matrix otherwise.\n\n\n\n","category":"function"},{"location":"varieties/","page":"Varieties","title":"Varieties","text":"Methods for Grassmannians.","category":"page"},{"location":"varieties/","page":"Varieties","title":"Varieties","text":"schubert_class\nschubert_classes","category":"page"},{"location":"varieties/#IntersectionTheory.schubert_class","page":"Varieties","title":"IntersectionTheory.schubert_class","text":"schubert_class(G::AbsVariety, λ::Int...)\nschubert_class(G::AbsVariety, λ::Vector{Int})\nschubert_class(G::AbsVariety, λ::Partition)\n\nReturn the Schubert class sigma_lambda on a (relative) Grassmannian G.\n\n\n\n","category":"function"},{"location":"varieties/#IntersectionTheory.schubert_classes","page":"Varieties","title":"IntersectionTheory.schubert_classes","text":"schubert_classes(m::Int, G::AbsVariety)\n\nReturn all the Schubert classes in codimension m on a (relative) Grassmannian G.\n\n\n\n","category":"function"},{"location":"varieties/#Examples-3","page":"Varieties","title":"Examples","text":"","category":"section"},{"location":"varieties/","page":"Varieties","title":"Varieties","text":"basis(proj(2))\nG = grassmannian(2, 4)\nbasis(G)\ndual_basis(G)\nbetti(G)\nbasis(2, G)\nintersection_matrix(basis(2, G))\nintersection_matrix(basis(2, G), dual_basis(2, G))\nintersection_matrix(G)\nschubert_class(G, [1,1])\nschubert_classes(2, G)","category":"page"},{"location":"varieties/","page":"Varieties","title":"Varieties","text":"Notice that intersection_matrix(X) contains a lot of redundant information: intersection numbers that are not in complementary codimensions are always 0. So usually it is better to separate the components in different codimensions.","category":"page"},{"location":"varieties/#Construct-new-varieties","page":"Varieties","title":"Construct new varieties","text":"","category":"section"},{"location":"varieties/","page":"Varieties","title":"Varieties","text":"See also Constructors.","category":"page"},{"location":"varieties/","page":"Varieties","title":"Varieties","text":"*(X::AbsVariety, Y::AbsVariety)\ncomplete_intersection\nsection_zero_locus\ndegeneracy_locus","category":"page"},{"location":"varieties/#Base.:*-Tuple{IntersectionTheory.AbsVariety, IntersectionTheory.AbsVariety}","page":"Varieties","title":"Base.:*","text":"*(X::AbsVariety, Y::AbsVariety)\n\nConstruct the product variety Xtimes Y. If both X and Y have a polarization, Xtimes Y will be endowed with the polarization of the Segre embedding.\n\n\n\n","category":"method"},{"location":"varieties/#IntersectionTheory.complete_intersection","page":"Varieties","title":"IntersectionTheory.complete_intersection","text":"complete_intersection(X::AbsVariety, degs::Int...)\ncomplete_intersection(X::AbsVariety, degs::Vector{Int})\n\nConstruct the complete intersection in X of general hypersurfaces with degrees d_1dotsd_k.\n\n\n\n","category":"function"},{"location":"varieties/#IntersectionTheory.section_zero_locus","page":"Varieties","title":"IntersectionTheory.section_zero_locus","text":"section_zero_locus(F::AbsBundle)\n\nConstruct the zero locus of a general section of a bundle F.\n\nUse the argument class=true to only compute the class of the zero locus (same as ctop(F)).\n\n\n\n","category":"function"},{"location":"varieties/#IntersectionTheory.degeneracy_locus","page":"Varieties","title":"IntersectionTheory.degeneracy_locus","text":"degeneracy_locus(k::Int, F::AbsBundle, G::AbsBundle)\n\nConstruct the k-degeneracy locus for a general bundle map from F to G.\n\nUse the argument class=true to only compute the class of the degeneracy locus.\n\n\n\n","category":"function"},{"location":"varieties/#Examples-4","page":"Varieties","title":"Examples","text":"","category":"section"},{"location":"varieties/","page":"Varieties","title":"Varieties","text":"proj(1) * proj(1)\ncomplete_intersection(proj(3), 4)\nsection_zero_locus(OO(proj(3), 4))\nX, (A, B) = variety(2, [3=>\"a\", 4=>\"b\"]);\nD = degeneracy_locus(2, A, B)\npushforward(D → X, D(1))\ndegeneracy_locus(2, A, B, class=true)","category":"page"},{"location":"dev/","page":"Development notes","title":"Development notes","text":"CurrentModule = IntersectionTheory\nDocTestSetup = quote\n  using IntersectionTheory\nend","category":"page"},{"location":"dev/","page":"Development notes","title":"Development notes","text":"using IntersectionTheory","category":"page"},{"location":"dev/#Development-notes","page":"Development notes","title":"Development notes","text":"","category":"section"},{"location":"dev/#Comparisons-with-other-packages","page":"Development notes","title":"Comparisons with other packages","text":"","category":"section"},{"location":"dev/","page":"Development notes","title":"Development notes","text":"This package is largely a translation of existing functionalities from Schubert2, Chow, and Schubert3 into Julia. Since most of the functionalities are already available elsewhere, the improvement in performance is important to justify its existence.","category":"page"},{"location":"dev/#*Schubert2*","page":"Development notes","title":"Schubert2","text":"","category":"section"},{"location":"dev/","page":"Development notes","title":"Development notes","text":"For Schubert2, we have already covered most of the functionalities, with the following exceptions:","category":"page"},{"location":"dev/","page":"Development notes","title":"Development notes","text":"Isotropic flag bundles;\nCorrespondence and IncidenceCorrespondence (what are the use cases for these?);\nBetter support for Schubert classes.\n","category":"page"},{"location":"dev/","page":"Development notes","title":"Development notes","text":"Polynomial arithmetics in Macaulay2 are quite slow compared to Nemo and Singular. So most computations will automatically run a lot faster in this package than Schubert2.","category":"page"},{"location":"dev/#*Chow*","page":"Development notes","title":"Chow","text":"","category":"section"},{"location":"dev/","page":"Development notes","title":"Development notes","text":"For Chow, (almost?) all functionalities are covered, notably the construction of parameter spaces for twisted cubics, which is one of its key features. Moreover, we implemented constructors for moduli spaces of matrices with arbitrary size.","category":"page"},{"location":"dev/","page":"Development notes","title":"Development notes","text":"Most computations in this package should run faster with a constant factor of 2 to 5 when compared to Chow, thanks to the high efficiency of the Julia/Oscar combo. Note that the blowup procedure in Chow is particularly inefficient. See below for comparisons.","category":"page"},{"location":"dev/#*Schubert3*","page":"Development notes","title":"Schubert3","text":"","category":"section"},{"location":"dev/","page":"Development notes","title":"Development notes","text":"For Schubert3, we implemented the functionality of computing integrals using Bott's formula on Grassmannians, and on flag varieties in general. Moduli spaces of maps (Kontsevich's spaces) are not implemented yet.","category":"page"},{"location":"dev/","page":"Development notes","title":"Development notes","text":"Again, most computations in this package should run faster with a constant factor.","category":"page"},{"location":"dev/#Others","page":"Development notes","title":"Others","text":"","category":"section"},{"location":"dev/","page":"Development notes","title":"Development notes","text":"A large part of the Singular library chern.lib is also covered.","category":"page"},{"location":"dev/#Benchmarks","page":"Development notes","title":"Benchmarks","text":"","category":"section"},{"location":"dev/","page":"Development notes","title":"Development notes","text":"All the timings are done on an Intel(R) Core(TM) i5-8350U CPU @ 1.70GHz.","category":"page"},{"location":"dev/#Computing-Todd-class","page":"Development notes","title":"Computing Todd class","text":"","category":"section"},{"location":"dev/","page":"Development notes","title":"Development notes","text":"julia> @time todd(proj(200));\n  0.353537 seconds (989.07 k allocations: 44.766 MiB, 4.73% gc time)","category":"page"},{"location":"dev/","page":"Development notes","title":"Development notes","text":"Chow:","category":"page"},{"location":"dev/","page":"Development notes","title":"Development notes","text":"sage: time t = Proj(200).tangent_bundle().todd_class();\nCPU times: user 1.23 s, sys: 715 µs, total: 1.23 s\nWall time: 1.19 s","category":"page"},{"location":"dev/","page":"Development notes","title":"Development notes","text":"Schubert3:","category":"page"},{"location":"dev/","page":"Development notes","title":"Development notes","text":"sage: time t = ProjectiveSpace(200).tangent_bundle().todd_class();\nCPU times: user 2.15 s, sys: 1.15 ms, total: 2.15 s\nWall time: 2.15 s","category":"page"},{"location":"dev/","page":"Development notes","title":"Development notes","text":"Schubert2 and chern.lib are far slower so are not included.","category":"page"},{"location":"dev/#Computing-blowup","page":"Development notes","title":"Computing blowup","text":"","category":"section"},{"location":"dev/","page":"Development notes","title":"Development notes","text":"The computation of the blowup requires a \"pushforward\" function. In Macaulay2 there are two functions that do this: pushForward, and pushFwd from the PushForward package. pushFwd eventually calls pushForward so they are in fact the same.","category":"page"},{"location":"dev/","page":"Development notes","title":"Development notes","text":"warning: Warning\nOur implementation is still not optimal and is slower than Macaulay2's: the step using std to reduce the module is slow. Is this a Singular problem?","category":"page"},{"location":"dev/","page":"Development notes","title":"Development notes","text":"On the other hand, the counterpart in Chow, FiniteRingExtension, is very inefficient. This makes blowups in Chow very slow.","category":"page"},{"location":"dev/","page":"Development notes","title":"Development notes","text":"We compute the blowup of mathbf P^20 at a point.","category":"page"},{"location":"dev/","page":"Development notes","title":"Development notes","text":"julia> @time blowup(point() → proj(20))[1] |> euler\n  0.011019 seconds (60.98 k allocations: 1.391 MiB)\n40","category":"page"},{"location":"dev/","page":"Development notes","title":"Development notes","text":"Schubert2:","category":"page"},{"location":"dev/","page":"Development notes","title":"Development notes","text":"i12 : p = abstractProjectiveSpace 0; time euler first blowup map(abstractProjectiveSpace 20, p, OO_p)\n     -- used 1.09486 seconds\n\no13 = 40","category":"page"},{"location":"dev/","page":"Development notes","title":"Development notes","text":"Chow:","category":"page"},{"location":"dev/","page":"Development notes","title":"Development notes","text":"sage: time Blowup(PointChowScheme.hom(\"0\", Proj(20))).codomain().euler_number()\nCPU times: user 16.7 s, sys: 6.9 ms, total: 16.7 s\nWall time: 16.8 s\n40","category":"page"},{"location":"dev/","page":"Development notes","title":"Development notes","text":"Schubert3 does not seem to provide this functionality.","category":"page"},{"location":"dev/","page":"Development notes","title":"Development notes","text":"Since the computations related to parameter spaces of twisted cubics use blowup, they run significantly faster in this package than with Chow.","category":"page"},{"location":"dev/","page":"Development notes","title":"Development notes","text":"Compute the number of twisted cubics on a quintic threefold twisted_cubics_on_quintic_threefold: 5s v.s. 1min;\nCompute the Euler number of the LLSvS eightfold twisted_cubics_on_cubic_fourfold: 2min v.s. 20min.","category":"page"},{"location":"dev/#Linear-subspaces-on-hypersurfaces","page":"Development notes","title":"Linear subspaces on hypersurfaces","text":"","category":"section"},{"location":"dev/#Using-Schubert-calculus","page":"Development notes","title":"Using Schubert calculus","text":"","category":"section"},{"location":"dev/","page":"Development notes","title":"Development notes","text":"julia> @time IntersectionTheory.linear_subspaces_on_hypersurface(1, 35, bott=false)\n  0.257564 seconds (1.66 M allocations: 30.382 MiB)\n513687287764790207960329434065844597978401438841796875\n\njulia> @time IntersectionTheory.linear_subspaces_on_hypersurface(2, 7, bott=false)\n  0.430082 seconds (2.68 M allocations: 42.083 MiB, 1.66% gc time)\n279101475496912988004267637","category":"page"},{"location":"dev/","page":"Development notes","title":"Development notes","text":"Schubert2:","category":"page"},{"location":"dev/","page":"Development notes","title":"Development notes","text":"i4 : time integral chern symmetricPower_35 dual first bundles flagBundle{2,18}\n     -- used 15.2021 seconds\n\no4 = 513687287764790207960329434065844597978401438841796875\n\ni5 : time integral chern symmetricPower_7 dual first bundles flagBundle{3,12}\n     -- used 12.3326 seconds\n\no5 = 279101475496912988004267637","category":"page"},{"location":"dev/","page":"Development notes","title":"Development notes","text":"Chow:","category":"page"},{"location":"dev/","page":"Development notes","title":"Development notes","text":"sage: time Grass(2,20).sheaves['universal_sub'].dual().symm(35).chern_classes()[-1].integral()\nCPU times: user 787 ms, sys: 12.6 ms, total: 800 ms\nWall time: 812 ms\n513687287764790207960329434065844597978401438841796875\n\nsage: time Grass(3,15).sheaves['universal_sub'].dual().symm(7).chern_classes()[-1].integral()\nCPU times: user 1.99 s, sys: 19.4 ms, total: 2.01 s\nWall time: 2.02 s\n279101475496912988004267637","category":"page"},{"location":"dev/","page":"Development notes","title":"Development notes","text":"Schubert3 is much slower and is not included.","category":"page"},{"location":"dev/#Using-Bott's-formula","page":"Development notes","title":"Using Bott's formula","text":"","category":"section"},{"location":"dev/","page":"Development notes","title":"Development notes","text":"julia> @time IntersectionTheory.linear_subspaces_on_hypersurface(1, 57)\n  0.263851 seconds (2.17 M allocations: 70.302 MiB, 36.51% gc time)\n4543008461967180205447462399408892034555800983810817102531043233080341547902307166123135185210701405\n\njulia> @time IntersectionTheory.linear_subspaces_on_hypersurface(3, 5)\n  0.546194 seconds (4.84 M allocations: 236.776 MiB, 31.41% gc time)\n64127725294951805931404297113125","category":"page"},{"location":"dev/","page":"Development notes","title":"Development notes","text":"Schubert3 is slightly a bit faster when k=1, but slower with bigger k.","category":"page"},{"location":"dev/","page":"Development notes","title":"Development notes","text":"sage: time linear_subspaces_hypersurface(1,57,30)\nCPU times: user 260 ms, sys: 0 ns, total: 260 ms\nWall time: 260 ms\n4543008461967180205447462399408892034555800983810817102531043233080341547902307166123135185210701405\n\nsage: time linear_subspaces_hypersurface(3,5,17)\nCPU times: user 2.15 s, sys: 0 ns, total: 2.15 s\nWall time: 2.15 s\n64127725294951805931404297113125","category":"page"},{"location":"dev/#Some-notes","page":"Development notes","title":"Some notes","text":"","category":"section"},{"location":"dev/#Quotient-rings","page":"Development notes","title":"Quotient rings","text":"","category":"section"},{"location":"dev/","page":"Development notes","title":"Development notes","text":"In a quotient ring, when should we do the reductions? It is obviously very costly to do this frequently; on the other hand, if we don't do it at all, we may accumulate some super complicated elements that will take a long time to reduce in the end. I find a good balance point is to do reduction for multiplications and powers, but not for additions and substractions. Here are some timings for a comparison. The bottleneck is when computing the Chern characters for the tautological subbundles using their Chern classes.","category":"page"},{"location":"dev/","page":"Development notes","title":"Development notes","text":"Current solution (reduction for * and ^ only)","category":"page"},{"location":"dev/","page":"Development notes","title":"Development notes","text":"julia> @time flag(3,6,9);\n  0.045371 seconds (489.13 k allocations: 6.366 MiB)","category":"page"},{"location":"dev/","page":"Development notes","title":"Development notes","text":"Reduction for all the operators","category":"page"},{"location":"dev/","page":"Development notes","title":"Development notes","text":"julia> @time flag(3,6,9);\n  0.161490 seconds (769.00 k allocations: 8.604 MiB)","category":"page"},{"location":"dev/","page":"Development notes","title":"Development notes","text":"No reduction at all","category":"page"},{"location":"dev/","page":"Development notes","title":"Development notes","text":"julia> @time flag(3,6,9);\n  1.168490 seconds (8.57 M allocations: 124.392 MiB, 1.07% gc time)","category":"page"},{"location":"dev/","page":"Development notes","title":"Development notes","text":"(Although this necessarily means that the ideal should be in a standard basis.)","category":"page"},{"location":"dev/#Notes-on-Chow-rings","page":"Development notes","title":"Notes on Chow rings","text":"","category":"section"},{"location":"dev/","page":"Development notes","title":"Development notes","text":"For a given AbsVariety, the underlying Singular ring of the Chow ring should never be modified: otherwise bundles already constructed will no longer be compatible. So whenever a new Singular ring is used, a new instance of AbsVariety should be created (e.g. _inclusion).\nOn the other hand, the ideal could be changed but one should be careful. In particular, since basis_by_degree is cached (this is necessary due to performance reasons, since we need to check the number of zero cycles when doing integration), changing the ideal may lead to issues. But trim! is an exception since it does not change the structure and is in fact needed before performing basis_by_degree (otherwise the ideal might not be 0-dimensional and we won't be able to use kbase).","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"CurrentModule = IntersectionTheory\nDocTestSetup = quote\n  using IntersectionTheory\nend","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"using IntersectionTheory","category":"page"},{"location":"intro/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"intro/#Abstract-varieties","page":"Introduction","title":"Abstract varieties","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"When doing intersection theory in this package, we are not working with concrete varieties defined by algebraic equations; rather, we work with abstract varieties that are represented by their Chow rings, an analogue of the cohomology ring.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"More precisely, we only work with projective smooth varieties defined over an algebraically closed field of characteristic 0 (or simply mathbf C). Let X be such a variety. A k-cycle on X is a formal linear combination of codimension-k subvarieties with rational coefficients, and a k-class is an equivalent class of cycles modulo numerical equivalence (see below). The Chow ring A^*(X) is a commutative graded ring, where A^k(X) are classes of codimension k, and the product is given by the intersection product A^k(X)times A^l(X)to A^k+l(X).","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Some remarks:","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Since we work with rational coefficients, we will not be able to see any torsion classes.\nFor practical reasons, we can use Singular's FunctionField (of type N_FField) as coefficients. This will allow us to introduce parameters and do some symbolic computations.\nUsually the rational equivalence is used for defining the Chow ring. But this is too fine an equivalence for us: we are actually working with numerical equivalence, that is, we only care about the intersection numbers with respect to classes in complementary codimension. This is enough for most enumerative problems, and another advantage is that we can deduce the pushforward of a morphism when only the pullback is known (see Morphisms for details).\nIn many cases, we won't be able to compute the entire Chow ring: we will only be able to obtain information on a certain subring generated by some tautological classes. Therefore we are actually working with the class of all varieties that share the same piece of tautological ring (see A \"non-algebraic\" example for a typical example).\nFor some nice varieties, the numerical equivalence coincides with the rational equivalence. In this case the Chow ring coincides with the rational cohomology ring and can be completely computed, so both problems disappear. A nice consequence is that the Betti numbers of the Chow ring are exactly the (even) Betti numbers of the variety itself, so we have an equality sum(betti(X)) == euler(X). The class of these varieties includes projective spaces, Grassmannians, homogeneous spaces for affine algebraic groups (e.g., flag varieties), and in general any variety with an affine stratification. Moreover, products, projective bundles, and blowups with center in this class will remain in this class. Internally, we use set_special(X, :alg => true) to declare that X satisfies this property. (maybe a better name?)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Technically, an abstract variety is given as an AbsVariety.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"AbsVariety","category":"page"},{"location":"intro/#IntersectionTheory.AbsVariety","page":"Introduction","title":"IntersectionTheory.AbsVariety","text":"AbsVariety(n::Int, R::ChRing)\n\nThe type of an abstract variety.\n\n\n\n","category":"type"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"It contains the following fields:","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"dim::Int: the dimension of the variety;\nring::ChRing: the Chow ring;\nbase: the coefficient ring, default is Singular.QQ;","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"and optionally, the following:","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"point: the class of a point, used for computing integrals;\nO1: a polarization class, if applicable;\nT: the tangent bundle of the variety;\nbundles: tautological bundles, if applicable;\nstruct_map: the structure map.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"See Constructors for available variety constructors, including projective spaces, Grassmannians, etc.","category":"page"},{"location":"intro/#Abstract-bundles","page":"Introduction","title":"Abstract bundles","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Since X is smooth, any coherent sheaf on X admits a finite resolution by locally-free sheaves, i.e., vector bundles. We get an isomorphism of Grothendieck rings K^0(X)simeq K_0(X). Therefore we will only speak of abstract bundles, which should be thought of as virtual bundles or complexes of bundles.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"By Grothendieck–Riemann–Roch theorem, the Chern character mathrmch provides an isomorphism from the Grothendieck ring K_0(X) to the Chow ring (modulo rational equivalence) over rational coefficients","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"mathrmch K_0(X)_mathbf Qxrightarrowsim A^*(X)_mathbf Q","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"So an abstract bundle will be represented by its Chern character. Equivalently, this can be determined by the rank and the total Chern class.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"AbsBundle","category":"page"},{"location":"intro/#IntersectionTheory.AbsBundle","page":"Introduction","title":"IntersectionTheory.AbsBundle","text":"AbsBundle(X::AbsVariety, ch::ChRingElem)\nAbsBundle(X::AbsVariety, r, c::ChRingElem)\n\nThe type of an abstract bundle.\n\n\n\n","category":"type"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"It contains the following fields:","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"parent::AbsVariety: the base variety;\nrank: the rank of the bundle, which can contain parameters so is not necessarily an Int;\nch: the Chern character;\nchern: the total Chern class.","category":"page"},{"location":"intro/#Abstract-variety-morphisms","page":"Introduction","title":"Abstract variety morphisms","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"An abstract variety morphism fXto Y is specified by the pullback f^*A^*(Y)to A^*(X) and the pushforward f_*A^*(X)to A^*(Y). The pullback is functorial so it should be a ring homomorphism (a ChAlgHom), while the pushforward is only a FunctionMap.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"AbsVarietyHom","category":"page"},{"location":"intro/#IntersectionTheory.AbsVarietyHom","page":"Introduction","title":"IntersectionTheory.AbsVarietyHom","text":"AbsVarietyHom(X::AbsVariety, Y::AbsVariety, fˣ::ChAlgHom, fₓ)\nAbsVarietyHom(X::AbsVariety, Y::AbsVariety, fˣ::Vector, fₓ)\n\nThe type of an abstract variety morphism.\n\n\n\n","category":"type"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"It contains the following fields:","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"domain::AbsVariety: the domain of the morphism;\ncodomain::AbsVariety: the codomain of the morphism;\ndim::Int: the relative dimension;\npullback::ChAlgHom;\npushforward::FunctionMap;","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"and optionally, the following:","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"O1: the class of a relative mathcal O(1), if applicable;\nT: the relative tangent bundle.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"See Morphisms for details on how to build morphisms and manipulate them.","category":"page"},{"location":"intro/#Varieties-with-a-torus-action-and-equivariant-bundles","page":"Introduction","title":"Varieties with a torus action and equivariant bundles","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"If X is a complex variety (or more generally, an orbifold) with a torus action that admits only isolated fixed points, Bott's localization formula expresses certain integrals as a sum over the fixed points. In the case of Grassmannians and flag varieties, there are natural torus actions and Bott's formula allows us to compute integrals using only combinatoric data.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"To model this, we have the following types.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"TnVariety","category":"page"},{"location":"intro/#IntersectionTheory.TnVariety","page":"Introduction","title":"IntersectionTheory.TnVariety","text":"TnVariety(n::Int, points)\n\nThe type of a variety with a torus action, represented by the fixed points.\n\n\n\n","category":"type"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"It has the following fields:","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"dim::Int: the dimension of the variety;\npoints::Vector{Pair{P, Int}}: a vector of fixed points and their orbifold multiplicities;\nT: the tangent bundle;\nbundles: tautological bundles, if applicable.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"TnBundle","category":"page"},{"location":"intro/#IntersectionTheory.TnBundle","page":"Introduction","title":"IntersectionTheory.TnBundle","text":"TnBundle(X::TnVariety, r::Int, f::Function)\n\nThe type of a torus-equivariant bundle, represented by its localizations to the fixed points of the base variety.\n\n\n\n","category":"type"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"It has the following fields:","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"parent::TnVariety: the base variety;\nrank::Int: the rank of the bundle;\nloc::Function: the localizations.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The localization/restriction of a TnBundle to each of the fixed points in X.points is a representation of type TnRep. They are stored as a function to allow lazy evaluation. This is crucial for large examples, since otherwise we may run into memory problems.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"TnRep","category":"page"},{"location":"intro/#IntersectionTheory.TnRep","page":"Introduction","title":"IntersectionTheory.TnRep","text":"TnRep(w::Vector)\n\nThe type of a representation of a torus, specified by its weights.\n\n\n\n","category":"type"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"It has fields:","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"n::Int: the dimension of the representation;\nw::Vector: the weights.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"We try to keep the same syntax for AbsVariety and TnVariety, and for AbsBundle and TnBundle, wherever possible. See the documentations for details.","category":"page"},{"location":"intro/#Graded-rings","page":"Introduction","title":"Graded rings","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The following types are implemented to handle graded rings with weights, and their quotients.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"ChRing\nChRingElem\nChAlgHom","category":"page"},{"location":"intro/#IntersectionTheory.ChRing","page":"Introduction","title":"IntersectionTheory.ChRing","text":"ChRing(R::MPolyRing, w::Vector{Int})\nChRing(R::MPolyRing, w::Vector{Int}, I::sideal)\n\nThe type of a graded ring, possibly equipped with an ideal to represent a quotient ring.\n\n\n\n","category":"type"},{"location":"intro/#IntersectionTheory.ChRingElem","page":"Introduction","title":"IntersectionTheory.ChRingElem","text":"ChRingElem(R::ChRing, f::RingElem)\n\nThe type of an element of a ChRing.\n\n\n\n","category":"type"},{"location":"intro/#IntersectionTheory.ChAlgHom","page":"Introduction","title":"IntersectionTheory.ChAlgHom","text":"ChAlgHom(A::ChRing, B::ChRing, image::Vector)\n\nThe type of a ring homomorphism between two ChRings.\n\n\n\n","category":"type"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"For a ChRingElem, its homogeneous components can be accessed via Julia's getindex interface.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"c = chern(proj(3))\nc[1]\nc[0:5]","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"note: Note\nFor performance reasons, an element of a quotient ring might not always be in reduced form. It can be simplified using simplify (return a copy) and simplify! (in place).","category":"page"},{"location":"bundles/","page":"Bundles","title":"Bundles","text":"CurrentModule = IntersectionTheory\nDocTestSetup = quote\n  using IntersectionTheory\nend","category":"page"},{"location":"bundles/","page":"Bundles","title":"Bundles","text":"using IntersectionTheory","category":"page"},{"location":"bundles/#Bundles","page":"Bundles","title":"Bundles","text":"","category":"section"},{"location":"bundles/","page":"Bundles","title":"Bundles","text":"We try to keep the same syntax for AbsBundle and TnBundle. Note that not all methods are available for TnBundle.","category":"page"},{"location":"bundles/#Construct-bundles","page":"Bundles","title":"Construct bundles","text":"","category":"section"},{"location":"bundles/","page":"Bundles","title":"Bundles","text":"bundle\nOO\nbundles\ntangent_bundle(X::AbsVariety)\ncotangent_bundle(X::AbsVariety)\ncanonical_bundle\ncanonical_class","category":"page"},{"location":"bundles/#IntersectionTheory.bundle","page":"Bundles","title":"IntersectionTheory.bundle","text":"bundle(X::AbsVariety, ch)\nbundle(X::AbsVariety, r, c)\n\nConstruct a bundle on X by specifying its Chern character, or its rank and total Chern class.\n\n\n\n","category":"function"},{"location":"bundles/#IntersectionTheory.OO","page":"Bundles","title":"IntersectionTheory.OO","text":"OO(X::AbsVariety)\nOO(X::TnVariety)\n\nReturn the trivial bundle mathcal O_X on X.\n\n\n\nOO(X::AbsVariety, n)\nOO(X::AbsVariety, D)\n\nReturn the line bundle mathcal O_X(n) on X if X has been given a polarization, or a line bundle mathcal O_X(D) with first Chern class D.\n\n\n\n","category":"function"},{"location":"bundles/#IntersectionTheory.bundles","page":"Bundles","title":"IntersectionTheory.bundles","text":"bundles(X::AbsVariety)\nbundles(X::TnVariety)\n\nReturn the tautological bundles of a variety X. Same as X.bundles.\n\n\n\n","category":"function"},{"location":"bundles/#IntersectionTheory.tangent_bundle-Tuple{IntersectionTheory.AbsVariety}","page":"Bundles","title":"IntersectionTheory.tangent_bundle","text":"tangent_bundle(X::AbsVariety)\ntangent_bundle(X::TnVariety)\n\nReturn the tangent bundle of a variety X. Same as X.T.\n\n\n\n","category":"method"},{"location":"bundles/#IntersectionTheory.cotangent_bundle-Tuple{IntersectionTheory.AbsVariety}","page":"Bundles","title":"IntersectionTheory.cotangent_bundle","text":"cotangent_bundle(X::AbsVariety)\ncotangent_bundle(X::TnVariety)\n\nReturn the cotangent bundle of a variety X.\n\n\n\n","category":"method"},{"location":"bundles/#IntersectionTheory.canonical_bundle","page":"Bundles","title":"IntersectionTheory.canonical_bundle","text":"canonical_bundle(X::AbsVariety)\n\nReturn the canonical bundle of a variety X.\n\n\n\n","category":"function"},{"location":"bundles/#IntersectionTheory.canonical_class","page":"Bundles","title":"IntersectionTheory.canonical_class","text":"canonical_class(X::AbsVariety)\n\nReturn the canonical class of a variety X.\n\n\n\n","category":"function"},{"location":"bundles/#Examples","page":"Bundles","title":"Examples","text":"","category":"section"},{"location":"bundles/","page":"Bundles","title":"Bundles","text":"OO(proj(2))\nbundles(grassmannian(2, 4))\nbundles(grassmannian(2, 4, bott=true))\ntangent_bundle(variety(3))","category":"page"},{"location":"bundles/#Characteristic-classes","page":"Bundles","title":"Characteristic classes","text":"","category":"section"},{"location":"bundles/","page":"Bundles","title":"Bundles","text":"ch\nchern(F::AbsBundle)\nchern(k::Int, F::AbsBundle)\nctop\nsegre\nchi\ntodd(F::AbsBundle)\npontryagin(F::AbsBundle)\npontryagin(k::Int, F::AbsBundle)","category":"page"},{"location":"bundles/#IntersectionTheory.ch","page":"Bundles","title":"IntersectionTheory.ch","text":"ch(F::AbsBundle)\n\nReturn the Chern character.\n\n\n\n","category":"function"},{"location":"bundles/#IntersectionTheory.chern-Tuple{IntersectionTheory.AbsBundle}","page":"Bundles","title":"IntersectionTheory.chern","text":"chern(F::AbsBundle)\nchern(F::TnBundle)\n\nCompute the total Chern class.\n\n\n\n","category":"method"},{"location":"bundles/#IntersectionTheory.chern-Tuple{Int64, IntersectionTheory.AbsBundle}","page":"Bundles","title":"IntersectionTheory.chern","text":"chern(k::Int, F::AbsBundle)\nchern(k::Int, F::TnBundle)\n\nCompute the k-th Chern class.\n\n\n\n","category":"method"},{"location":"bundles/#IntersectionTheory.ctop","page":"Bundles","title":"IntersectionTheory.ctop","text":"ctop(F::AbsBundle)\nctop(F::TnBundle)\n\nCompute the top Chern class.\n\n\n\n","category":"function"},{"location":"bundles/#IntersectionTheory.segre","page":"Bundles","title":"IntersectionTheory.segre","text":"segre(F::AbsBundle)\n\nCompute the total Segre class.\n\n\n\nsegre(k::Int, F::AbsBundle)\n\nCompute the k-th Segre class.\n\n\n\n","category":"function"},{"location":"bundles/#IntersectionTheory.chi","page":"Bundles","title":"IntersectionTheory.chi","text":"chi(F::AbsBundle)\nchi(F::AbsBundle, G::AbsBundle)\n\nCompute the holomorphic Euler characteristic chi(F), or the Euler pairing chi(FG).\n\n\n\n","category":"function"},{"location":"bundles/#IntersectionTheory.todd-Tuple{IntersectionTheory.AbsBundle}","page":"Bundles","title":"IntersectionTheory.todd","text":"todd(F::AbsBundle)\n\nCompute the Todd class.\n\n\n\n","category":"method"},{"location":"bundles/#IntersectionTheory.pontryagin-Tuple{IntersectionTheory.AbsBundle}","page":"Bundles","title":"IntersectionTheory.pontryagin","text":"pontryagin(F::AbsBundle)\n\nCompute the total Pontryagin class.\n\n\n\n","category":"method"},{"location":"bundles/#IntersectionTheory.pontryagin-Tuple{Int64, IntersectionTheory.AbsBundle}","page":"Bundles","title":"IntersectionTheory.pontryagin","text":"pontryagin(k::Int, F::AbsBundle)\n\nCompute the k-th Pontryagin class.\n\n\n\n","category":"method"},{"location":"bundles/","page":"Bundles","title":"Bundles","text":"note: Note\nFor a TnBundle of rank r, since there are no Chow ring present, its Chern classes are represented as formal polynomials in r variables. Arithmetics are only available for Chern classes of a same TnBundle. See examples below.","category":"page"},{"location":"bundles/#Examples-2","page":"Bundles","title":"Examples","text":"","category":"section"},{"location":"bundles/","page":"Bundles","title":"Bundles","text":"For AbsBundle.","category":"page"},{"location":"bundles/","page":"Bundles","title":"Bundles","text":"X, (F,) = variety(2, [2=>\"c\"]);\nch(F)\nchern(F)\npontryagin(F)\nchern(proj(2))\nchern(2, proj(2))\ntodd(proj(2))\nchi(cotangent_bundle(proj(2)))\nG = grassmannian(2, 4); S, Q = bundles(G);\nchern(1, S)\nintegral(chern(1, S)^4)\nchern(1, S) * chern(2, Q)","category":"page"},{"location":"bundles/","page":"Bundles","title":"Bundles","text":"For TnBundle.","category":"page"},{"location":"bundles/","page":"Bundles","title":"Bundles","text":"G = grassmannian(2, 4, bott=true); S, Q = bundles(G);\nchern(1, S)\nintegral(chern(1, S)^4)\nchern(1, S) * chern(2, Q) # this will not work","category":"page"},{"location":"bundles/#Operators","page":"Bundles","title":"Operators","text":"","category":"section"},{"location":"bundles/","page":"Bundles","title":"Bundles","text":"symmetric_power\nexterior_power\ndet\ndual\nschur_functor","category":"page"},{"location":"bundles/#IntersectionTheory.symmetric_power","page":"Bundles","title":"IntersectionTheory.symmetric_power","text":"symmetric_power(k, F::AbsBundle)\nsymmetric_power(k::Int, F::TnBundle)\n\nReturn the k-th symmetric power. For an AbsBundle, k can contain parameters.\n\n\n\n","category":"function"},{"location":"bundles/#IntersectionTheory.exterior_power","page":"Bundles","title":"IntersectionTheory.exterior_power","text":"exterior_power(k::Int, F::AbsBundle)\nexterior_power(k::Int, F::TnBundle)\n\nReturn the k-th exterior power.\n\n\n\n","category":"function"},{"location":"bundles/#LinearAlgebra.det","page":"Bundles","title":"LinearAlgebra.det","text":"det(F::AbsBundle)\ndet(F::TnBundle)\n\nReturn the determinant bundle.\n\n\n\n","category":"function"},{"location":"bundles/#IntersectionTheory.dual","page":"Bundles","title":"IntersectionTheory.dual","text":"dual(F::AbsBundle)\ndual(F::TnBundle)\n\nReturn the dual bundle.\n\n\n\n","category":"function"},{"location":"bundles/#IntersectionTheory.schur_functor","page":"Bundles","title":"IntersectionTheory.schur_functor","text":"schur_functor(λ::Vector{Int}, F::AbsBundle)\nschur_functor(λ::Partition, F::AbsBundle)\n\nReturn the result of the Schur functor mathbf S^lambda.\n\n\n\n","category":"function"},{"location":"cubic_fourfold/","page":"Special cubic fourfolds","title":"Special cubic fourfolds","text":"CurrentModule = IntersectionTheory\nDocTestSetup = quote\n  using IntersectionTheory\nend","category":"page"},{"location":"cubic_fourfold/","page":"Special cubic fourfolds","title":"Special cubic fourfolds","text":"using IntersectionTheory","category":"page"},{"location":"cubic_fourfold/#Special-cubic-fourfolds","page":"Special cubic fourfolds","title":"Special cubic fourfolds","text":"","category":"section"},{"location":"cubic_fourfold/","page":"Special cubic fourfolds","title":"Special cubic fourfolds","text":"Cubic fourfolds are degree-3 smooth hypersurfaces in mathbf P^5. They can be constructed using complete_intersection.","category":"page"},{"location":"cubic_fourfold/","page":"Special cubic fourfolds","title":"Special cubic fourfolds","text":"Y = complete_intersection(proj(5), 3)\nbasis(Y)","category":"page"},{"location":"cubic_fourfold/","page":"Special cubic fourfolds","title":"Special cubic fourfolds","text":"We see that a generic Y only contains classes that are complete intersections.","category":"page"},{"location":"cubic_fourfold/","page":"Special cubic fourfolds","title":"Special cubic fourfolds","text":"Special cubic fourfolds are those that contain a surface not homologous to a complete intersection, i.e. they have extra algebraic classes. We can construct a surface S as follows.","category":"page"},{"location":"cubic_fourfold/","page":"Special cubic fourfolds","title":"Special cubic fourfolds","text":"S, (h, c1, c2) = variety(2, [\"h\", \"c1\", \"c2\"], [1, 1, 2])\nS.T = bundle(S, 2, 1 + c1 + c2)\ntrim!(S.ring);\nbasis(S)","category":"page"},{"location":"cubic_fourfold/","page":"Special cubic fourfolds","title":"Special cubic fourfolds","text":"Here we first built a generic 2-dimensional variety with some classes, then we specified its tangent bundle. The step trim! is to get rid of classes that have codimension larger than 2.","category":"page"},{"location":"cubic_fourfold/","page":"Special cubic fourfolds","title":"Special cubic fourfolds","text":"Now we build the inclusion.","category":"page"},{"location":"cubic_fourfold/","page":"Special cubic fourfolds","title":"Special cubic fourfolds","text":"i = hom(S, Y, [h])","category":"page"},{"location":"cubic_fourfold/","page":"Special cubic fourfolds","title":"Special cubic fourfolds","text":"The self-intersection number of S in Y is equal to the top Chern class of the normal bundle, while this latter can be accessed as the negative of the relative tangent bundle of i.","category":"page"},{"location":"cubic_fourfold/","page":"Special cubic fourfolds","title":"Special cubic fourfolds","text":"ctop(-i.T)","category":"page"},{"location":"cubic_fourfold/","page":"Special cubic fourfolds","title":"Special cubic fourfolds","text":"Since we saw that there is no algebraic class in Y for the surface S, the classes on S cannot be pushforward to Y.","category":"page"},{"location":"cubic_fourfold/","page":"Special cubic fourfolds","title":"Special cubic fourfolds","text":"pushforward(i, S(1))","category":"page"},{"location":"cubic_fourfold/","page":"Special cubic fourfolds","title":"Special cubic fourfolds","text":"To overcome this we may use the argument inclusion=true when building the inclusion. The returned inclusion will then have its codomain a modified version of Y, with extra classes added.","category":"page"},{"location":"cubic_fourfold/","page":"Special cubic fourfolds","title":"Special cubic fourfolds","text":"j = hom(S, Y, [h], inclusion=true, symbol=\"s\")\nY₁ = j.codomain\nbasis(Y₁)","category":"page"},{"location":"cubic_fourfold/","page":"Special cubic fourfolds","title":"Special cubic fourfolds","text":"Now we can pushforward classes on S.","category":"page"},{"location":"cubic_fourfold/","page":"Special cubic fourfolds","title":"Special cubic fourfolds","text":"pushforward(j, S(1))\npushforward(j, ctop(-j.T))","category":"page"},{"location":"cubic_fourfold/#Cubic-fourfolds-containing-a-degree-5-del-Pezzo-surface","page":"Special cubic fourfolds","title":"Cubic fourfolds containing a degree-5 del Pezzo surface","text":"","category":"section"},{"location":"cubic_fourfold/","page":"Special cubic fourfolds","title":"Special cubic fourfolds","text":"We compute with a more explicit surface. A degree-5 del Pezzo surface can be constructed as the projective plane blown up at 4 points.","category":"page"},{"location":"cubic_fourfold/","page":"Special cubic fourfolds","title":"Special cubic fourfolds","text":"S = proj(2)\nfor i in 1:4\n  S = blowup(point() → S, symbol=\"E$i\")[1]\nend\nbasis(S)","category":"page"},{"location":"cubic_fourfold/","page":"Special cubic fourfolds","title":"Special cubic fourfolds","text":"It can be embedded in a special cubic fourfold Y_1 via the anti-canonical linear system.","category":"page"},{"location":"cubic_fourfold/","page":"Special cubic fourfolds","title":"Special cubic fourfolds","text":"K = canonical_class(S)\nchi(OO(S, -K))\ni = hom(S, Y, [-K], inclusion=true, symbol=\"s\")\nY₁ = i.codomain","category":"page"},{"location":"cubic_fourfold/","page":"Special cubic fourfolds","title":"Special cubic fourfolds","text":"The cubic fourfold is rational in this case: a rational map to mathbf P^4 can be given by the linear system of quadric hypersurfaces containing S. Numerically, we compute the blowup of Y_1 along S and study the divisor 2h-e.","category":"page"},{"location":"cubic_fourfold/","page":"Special cubic fourfolds","title":"Special cubic fourfolds","text":"Bl, E = blowup(i)\nh = pullback(Bl → Y₁, Y₁.O1)\ne = pushforward(E → Bl, E(1))\nintegral((2h - e)^4)\nchi(OO(Bl, 2h - e))","category":"page"},{"location":"curves_on_quintic/","page":"Rational curves on a quintic threefold","title":"Rational curves on a quintic threefold","text":"CurrentModule = IntersectionTheory\nDocTestSetup = quote\n  using IntersectionTheory\nend","category":"page"},{"location":"curves_on_quintic/","page":"Rational curves on a quintic threefold","title":"Rational curves on a quintic threefold","text":"using IntersectionTheory","category":"page"},{"location":"curves_on_quintic/#Rational-curves-on-a-quintic-threefold","page":"Rational curves on a quintic threefold","title":"Rational curves on a quintic threefold","text":"","category":"section"},{"location":"curves_on_quintic/","page":"Rational curves on a quintic threefold","title":"Rational curves on a quintic threefold","text":"Quintic threefolds are degree-5 smooth hypersurfaces in mathbf P^4. To fix notations we will write mathbf P(V_5) for the projective space, where V_5 is a fixed 5-dimensional vector space, fin mathrmSym^5V_5^vee for a quintic polynomial, and X=V(f) for the quintic threefold.","category":"page"},{"location":"curves_on_quintic/","page":"Rational curves on a quintic threefold","title":"Rational curves on a quintic threefold","text":"It is conjectured by Clemens that there are a finite number of rational curves in each degree on a generic quintic threefold (this means that if we look inside the space of all quintic polynomials f, there is a Zariski dense subset on which this is true).","category":"page"},{"location":"curves_on_quintic/","page":"Rational curves on a quintic threefold","title":"Rational curves on a quintic threefold","text":"The virtual numbers of rational curves in each degree were predicted by mirror symmetry, and proved using moduli spaces of maps and localization formula. In lower degrees, the virtual number is equal to the actual number of rational curves. Here we compute this number for degrees 1,2, and 3, following the documentation of Chow.","category":"page"},{"location":"curves_on_quintic/#Lines","page":"Rational curves on a quintic threefold","title":"Lines","text":"","category":"section"},{"location":"curves_on_quintic/","page":"Rational curves on a quintic threefold","title":"Rational curves on a quintic threefold","text":"This is a classical result obtained by Schubert. We consider the Grassmannian G=mathrmGr(2V_5) that parametrizes lines in mathbf P(V_5). Let S be the tautological subbundle. The quintic polynomial f gives a section of the vector bundle mathrmSym^5S^vee by restriction (i.e., at a point V_2 we get f_V_2in mathrmSym^5 V_2^vee), so the number of lines is equal to the top Chern class of this bundle.","category":"page"},{"location":"curves_on_quintic/","page":"Rational curves on a quintic threefold","title":"Rational curves on a quintic threefold","text":"G = grassmannian(2, 5)\nS = G.bundles[1]\nintegral(ctop(symmetric_power(5, dual(S))))","category":"page"},{"location":"curves_on_quintic/#Conics","page":"Rational curves on a quintic threefold","title":"Conics","text":"","category":"section"},{"location":"curves_on_quintic/","page":"Rational curves on a quintic threefold","title":"Rational curves on a quintic threefold","text":"This number is obtained by Katz. A conic spans a unique plane mathbf P(V_3) and gives a point V_3 in G=mathrmGr(3V_5). Conversely, for each V_3 there is a projective space mathbf P(mathrmSym^2V_3^vee) parametrizing conics contained in it. In the relative setting, we are thus inside the projective bundle M=mathbf P_G(mathrmSym^2S^vee), where each point is a pair (V_3q) with qin mathbf P(mathrmSym^2V_3^vee).","category":"page"},{"location":"curves_on_quintic/","page":"Rational curves on a quintic threefold","title":"Rational curves on a quintic threefold","text":"G = grassmannian(3, 5)\nS = G.bundles[1]\nM = proj(symmetric_power(2, dual(S)))","category":"page"},{"location":"curves_on_quintic/","page":"Rational curves on a quintic threefold","title":"Rational curves on a quintic threefold","text":"At each V_3, the restriction f_V_3 defines a plane quintic curve (i.e., the intersection Xcap mathbf P(V_3)). If we want a given conic V(q) to be contained in X, the quintic should split into the product of q and a cubic. In other words, f_V_3in mathrmSym^5V_3^vee should lie in the subspace langle qrangleotimes mathrmSym^3V_3^vee.","category":"page"},{"location":"curves_on_quintic/","page":"Rational curves on a quintic threefold","title":"Rational curves on a quintic threefold","text":"In the relative setting, langle qrangle becomes the tautological subbundle T on M, and we get a bundle map","category":"page"},{"location":"curves_on_quintic/","page":"Rational curves on a quintic threefold","title":"Rational curves on a quintic threefold","text":"Totimes mathrmSym^3S^veehookrightarrow mathrmSym^5S^vee","category":"page"},{"location":"curves_on_quintic/","page":"Rational curves on a quintic threefold","title":"Rational curves on a quintic threefold","text":"We can view f as a section of the quotient bundle B=mathrmSym^5S^vee(Totimes mathrmSym^3S^vee), and the set of conics is precisely determined by the vanishing of this section. Again it suffices to compute the top Chern class of B.","category":"page"},{"location":"curves_on_quintic/","page":"Rational curves on a quintic threefold","title":"Rational curves on a quintic threefold","text":"T = M.bundles[1]\nB = symmetric_power(5, dual(S)) - T * symmetric_power(3, dual(S))\nintegral(chern(B))","category":"page"},{"location":"curves_on_quintic/#Twisted-cubics","page":"Rational curves on a quintic threefold","title":"Twisted cubics","text":"","category":"section"},{"location":"curves_on_quintic/","page":"Rational curves on a quintic threefold","title":"Rational curves on a quintic threefold","text":"This number is computed by Ellingsrud and Strømme. The problem is a lot more complicated, due to the fact that a twisted cubic is not a complete intersection. We will need to first understand their parameter space.","category":"page"},{"location":"curves_on_quintic/#The-parameter-space-of-twisted-cubics","page":"Rational curves on a quintic threefold","title":"The parameter space of twisted cubics","text":"","category":"section"},{"location":"curves_on_quintic/","page":"Rational curves on a quintic threefold","title":"Rational curves on a quintic threefold","text":"We begin by describing the parameter space of twisted cubics in mathbf P^3=mathbf P(V_4). The Hilbert scheme mathrmHilb_3t+1 mathbf P^3 has two irreducible components: the one that parametrizes twisted cubics has dimension 12 and will be denoted as H; the other parametrizes smooth plane cubic curves plus a point in space, and has dimension 15. They intersect along a divisor Y in H, parametrizing singular plane cubics with an embedded point at the singularity.","category":"page"},{"location":"curves_on_quintic/","page":"Rational curves on a quintic threefold","title":"Rational curves on a quintic threefold","text":"The twisted cubic is not a complete intersection: its ideal is generated by 3 quadric equations that have linear relations. Equivalently, this means that they can be given as the 2-minors of a 3times 2 matrix of linear forms on V_4 (i.e., a net of quadrics that is determinantal).","category":"page"},{"location":"curves_on_quintic/","page":"Rational curves on a quintic threefold","title":"Rational curves on a quintic threefold","text":"There is a good moduli space N(qmn) parametrizing ntimes m matrices of linear forms on a q-dimensional vector space, as long as we have mathrmgcd(mn) = 1: this is realized as a GIT quotient by the group mathrmGL(m)times mathrmGL(n). There are two tautological bundles E and F of rank n and m on the moduli space, whose Chern classes generate the Chow ring. We may thus obtain an explicite description: this can be done by the function matrix_moduli(q,m,n).","category":"page"},{"location":"curves_on_quintic/","page":"Rational curves on a quintic threefold","title":"Rational curves on a quintic threefold","text":"X = matrix_moduli(4,2,3)","category":"page"},{"location":"curves_on_quintic/","page":"Rational curves on a quintic threefold","title":"Rational curves on a quintic threefold","text":"Let X be the moduli space N(423). By sending each twisted cubic to the matrix of its ideal, we get a rational map from H to X. This is a birational map; in fact, it is the blowup along a subvariety iIhookrightarrow X, and Y is the exceptional divisor. Points in I correspond to ideals of a plane plus an embedded point, and I is isomorphic to the incidence subvariety in mathbf P(V_4)times mathbf P(V_4^vee) consisting of pairs (pf) such that f vanishes at p. The fiber of Hto X at each point of I consists of all singular plane cubics passing doubly through the distinguished point: this is a linear condition and we get a mathbf P^6.","category":"page"},{"location":"curves_on_quintic/#Twisted-cubics-on-a-quintic-threefold","page":"Rational curves on a quintic threefold","title":"Twisted cubics on a quintic threefold","text":"","category":"section"},{"location":"curves_on_quintic/","page":"Rational curves on a quintic threefold","title":"Rational curves on a quintic threefold","text":"Now that the parameter space H has been worked out, we can go to the relative setting. A twisted cubic generates a unique mathbf P(V_4) and gives a point in G=mathrmGr(4V_5). We construct the relative version of X and I with respect to the rank-4 subbundle.","category":"page"},{"location":"curves_on_quintic/","page":"Rational curves on a quintic threefold","title":"Rational curves on a quintic threefold","text":"G = grassmannian(4, 5)\nV = G.bundles[1]\nX = matrix_moduli(V, 2, 3)\nF, E = X.bundles;","category":"page"},{"location":"curves_on_quintic/","page":"Rational curves on a quintic threefold","title":"Rational curves on a quintic threefold","text":"The incidence variety I and its tautological bundles.","category":"page"},{"location":"curves_on_quintic/","page":"Rational curves on a quintic threefold","title":"Rational curves on a quintic threefold","text":"PV = proj(V)\nS, Q = PV.bundles;\nI = proj(dual(Q))\nT, R = I.bundles;","category":"page"},{"location":"curves_on_quintic/","page":"Rational curves on a quintic threefold","title":"Rational curves on a quintic threefold","text":"The inclusion iIhookrightarrow X.","category":"page"},{"location":"curves_on_quintic/","page":"Rational curves on a quintic threefold","title":"Rational curves on a quintic threefold","text":"iˣE = T * dual(Q)\niˣF = T * dual(R) * det(dual(Q))\nimage = vcat(chern(iˣE)[1:3], chern(iˣF)[1:2], (I → G).pullback.(gens(G.ring)));\ni = hom(I, X, image, :alg)","category":"page"},{"location":"curves_on_quintic/","page":"Rational curves on a quintic threefold","title":"Rational curves on a quintic threefold","text":"Blowing up I and compute the Chern class, which leads to the final result.","category":"page"},{"location":"curves_on_quintic/","page":"Rational curves on a quintic threefold","title":"Rational curves on a quintic threefold","text":"H, Y = blowup(i)\nA = OO(H) * symmetric_power(5, dual(V)) - (E * symmetric_power(3, dual(V)) - F * symmetric_power(2, dual(V)))\nB = pushforward(Y → H, symmetric_power(2, dual(S) + R) * det(dual(Q)) * OO(Y, -1))\nintegral(chern(A - B))","category":"page"},{"location":"curves_on_quintic/","page":"Rational curves on a quintic threefold","title":"Rational curves on a quintic threefold","text":"The entire computation is available as the function twisted_cubics_on_quintic_threefold.","category":"page"},{"location":"curves_on_quintic/","page":"Rational curves on a quintic threefold","title":"Rational curves on a quintic threefold","text":"julia> @time IntersectionTheory.twisted_cubics_on_quintic_threefold()\n  4.150781 seconds (25.35 M allocations: 334.548 MiB, 1.02% gc time)\n317206375","category":"page"},{"location":"curves_on_quintic/","page":"Rational curves on a quintic threefold","title":"Rational curves on a quintic threefold","text":"The above is computed on an Intel(R) Core(TM) i5-8350U CPU @ 1.70GHz, while the same computation in Chow requires a full minute. This showcases the high efficiency of the Julia/Oscar combo (although some components of the blowup procedure in Chow are far from optimal; we implemented the algorithms from Macaulay2 instead).","category":"page"},{"location":"#IntersectionTheory","page":"About","title":"IntersectionTheory","text":"","category":"section"},{"location":"","page":"About","title":"About","text":"(Image: )","category":"page"},{"location":"","page":"About","title":"About","text":"IntersectionTheory is a Julia package for doing computations in intersection theory, built on top of Nemo and Singular.jl.","category":"page"},{"location":"","page":"About","title":"About","text":"It's heavily inspired by the Macaulay2 package Schubert2 and the Sage library Chow. Some functionalities from Schubert3 are also implemented. Compared to these, the advantage is the vast improvement in performance due to the efficiency of Julia, Nemo, and Singular.","category":"page"},{"location":"#Installation","page":"About","title":"Installation","text":"","category":"section"},{"location":"","page":"About","title":"About","text":"Hopefully this will be shipped with Oscar in the future. Right now it can be installed as follows.","category":"page"},{"location":"","page":"About","title":"About","text":"julia> using Pkg\njulia> Pkg.add(url=\"https://github.com/8d1h/IntersectionTheory\")","category":"page"},{"location":"#Functionalities","page":"About","title":"Functionalities","text":"","category":"section"},{"location":"","page":"About","title":"About","text":"ChRing and ChRingElem for handling graded rings with weights, and their quotients;\nBasic constructions for doing intersection theory, including AbsVariety represented by the Chow ring, AbsBundle represented by Chern characters, AbsVarietyHom for morphisms, and various operators that can be used on them;\nBlowing up subvarieties;\nConstructors for projective spaces, Grassmannians, flag varieties, and their relative versions;\nConstructors for moduli spaces of matrices, and parameter spaces of twisted cubics;\nSome basic functionalities for computing integrals using Bott's formula, including TnVariety for varieties with a torus action, and TnBundle for equivariant bundles;\nConstructors for Grassmannians and flag varieties as TnVariety.","category":"page"},{"location":"morphisms/","page":"Morphisms","title":"Morphisms","text":"CurrentModule = IntersectionTheory\nDocTestSetup = quote\n  using IntersectionTheory\nend","category":"page"},{"location":"morphisms/","page":"Morphisms","title":"Morphisms","text":"using IntersectionTheory","category":"page"},{"location":"morphisms/#Morphisms","page":"Morphisms","title":"Morphisms","text":"","category":"section"},{"location":"morphisms/#Construct-morphisms","page":"Morphisms","title":"Construct morphisms","text":"","category":"section"},{"location":"morphisms/","page":"Morphisms","title":"Morphisms","text":"A variety morphism can be built using the function hom.","category":"page"},{"location":"morphisms/","page":"Morphisms","title":"Morphisms","text":"hom(X::AbsVariety, Y::AbsVariety, fˣ::Vector, fₓ=nothing)","category":"page"},{"location":"morphisms/#IntersectionTheory.hom","page":"Morphisms","title":"IntersectionTheory.hom","text":"hom(X::AbsVariety, Y::AbsVariety, fˣ::Vector)\nhom(X::AbsVariety, Y::AbsVariety, fˣ::Vector, fₓ)\n\nConstruct a variety morphism from X to Y, by specifying the pullbacks of the generators of the Chow ring of Y. The pushforward can be automatically computed in certain cases.\n\nIn case of an inclusion iXhookrightarrow Y where the class of X is not present in the Chow ring of Y, use the argument inclusion=true. A copy of Y will be created, with extra classes added so that one can pushforward classes on X.\n\n\n\n","category":"function"},{"location":"morphisms/","page":"Morphisms","title":"Morphisms","text":"The pullback is relatively easy to describe since it's functorial, while the pushforward is usually more complicated. In some cases, the pushforward can be automatically computed from the pullback. Specifically, the projection formula tells us","category":"page"},{"location":"morphisms/","page":"Morphisms","title":"Morphisms","text":"forall xin A^*(X)yin A^*(Y)quad f_*(xcdot f^*y) = f_*xcdot y","category":"page"},{"location":"morphisms/","page":"Morphisms","title":"Morphisms","text":"Since we are working with numerical equivalence, to determine f_*x, it suffices to know all its intersection numbers, which can readily be computed using the pullback. However, for this to work, it is important that all the algebraic classes of Y are present (or at least those having non-zero intersection numbers with f_*x). This is the case in the following situations:","category":"page"},{"location":"morphisms/","page":"Morphisms","title":"Morphisms","text":"When Y is a point or a curve;\nWhen all the algebraic classes on Y are known, which can be declared by using set_special(Y, :alg => true);\nWhen :alg is passed as the fourth argument. This can be used when we are certain that the pushforward computed is correct, even though not all classes on Y are present.","category":"page"},{"location":"morphisms/","page":"Morphisms","title":"Morphisms","text":"In other cases, a warning will be given if one tries to do pushforward.","category":"page"},{"location":"morphisms/#Examples","page":"Morphisms","title":"Examples","text":"","category":"section"},{"location":"morphisms/#Veronese-embeddings-and-Segre-embeddings","page":"Morphisms","title":"Veronese embeddings and Segre embeddings","text":"","category":"section"},{"location":"morphisms/","page":"Morphisms","title":"Morphisms","text":"P2 = proj(2)\nchi(OO(P2, 2))\nv = hom(P2, proj(5), [2P2.O1])","category":"page"},{"location":"morphisms/","page":"Morphisms","title":"Morphisms","text":"P = proj(2)\nPxP = P * P\nchi(OO(PxP, 1))\ns = hom(PxP, proj(8), [PxP.O1])","category":"page"},{"location":"morphisms/#Inclusion-of-the-diagonal-in-the-product","page":"Morphisms","title":"Inclusion of the diagonal in the product","text":"","category":"section"},{"location":"morphisms/","page":"Morphisms","title":"Morphisms","text":"We create two copies of mathbf P^2 so that they have different variables.","category":"page"},{"location":"morphisms/","page":"Morphisms","title":"Morphisms","text":"Ph, Pk = proj(2, symbol=\"h\"), proj(2, symbol=\"k\")\nPxP = Ph * Pk\nD = proj(2) # the diagonal\ni = hom(D, PxP, [D.O1, D.O1])\npushforward(i, D(1)) # the class of the diagonal","category":"page"},{"location":"morphisms/#A-\"non-algebraic\"-example","page":"Morphisms","title":"A \"non-algebraic\" example","text":"","category":"section"},{"location":"morphisms/","page":"Morphisms","title":"Morphisms","text":"Here is an example to illustrate what can go wrong when we try to pushforward \"non-algebraic\" classes, i.e., classes that are not present.","category":"page"},{"location":"morphisms/","page":"Morphisms","title":"Morphisms","text":"Consider a cubic surface S. We can build it in two ways:","category":"page"},{"location":"morphisms/","page":"Morphisms","title":"Morphisms","text":"We can build it as a (hyper)surface in mathbf P^3, then in codimension 1 we only get the class of a (hyper)plane section.","category":"page"},{"location":"morphisms/","page":"Morphisms","title":"Morphisms","text":"S1 = section_zero_locus(OO(proj(3), 3))\nbasis(S1)","category":"page"},{"location":"morphisms/","page":"Morphisms","title":"Morphisms","text":"We can realize it as mathbf P^2 blown up at 6 points, so the cohomology is entirely algebraic with Betti numbers 1,7,1.","category":"page"},{"location":"morphisms/","page":"Morphisms","title":"Morphisms","text":"S2 = proj(2)\nfor i in 1:6\n  S2 = blowup(point() → S2, symbol=\"e$i\")[1]\nend\nbasis(S2)","category":"page"},{"location":"morphisms/","page":"Morphisms","title":"Morphisms","text":"The linear system on S_2 that provides the embedding into mathbf P^3 can be given by H=3h-sum e_i.","category":"page"},{"location":"morphisms/","page":"Morphisms","title":"Morphisms","text":"e, h = gens(S2.ring)[1:6], gens(S2.ring)[end]\nH = 3h - sum(e)\nchi(OO(S2, H))\nintegral(H^2)","category":"page"},{"location":"morphisms/","page":"Morphisms","title":"Morphisms","text":"This means that we can define a map fS_2to S_1 which is in fact an isomorphism.","category":"page"},{"location":"morphisms/","page":"Morphisms","title":"Morphisms","text":"f = hom(S2, S1, [H])\nf.dim, ch(f.T) # the relative tangent bundle is trivial","category":"page"},{"location":"morphisms/","page":"Morphisms","title":"Morphisms","text":"But we won't be able to pushforward classes on S_2 to S_1, since they are not present in S_1 hence \"non-algebraic\".","category":"page"},{"location":"morphisms/","page":"Morphisms","title":"Morphisms","text":"pushforward(f, e[1])","category":"page"},{"location":"morphisms/","page":"Morphisms","title":"Morphisms","text":"We received a warning and the result is indeed wrong: the exceptional divisors are not homologous to complete intersections.","category":"page"},{"location":"morphisms/#Canonically-defined-morphisms","page":"Morphisms","title":"Canonically defined morphisms","text":"","category":"section"},{"location":"morphisms/","page":"Morphisms","title":"Morphisms","text":"hom(X::AbsVariety, Y::AbsVariety)","category":"page"},{"location":"morphisms/#IntersectionTheory.hom-Tuple{IntersectionTheory.AbsVariety, IntersectionTheory.AbsVariety}","page":"Morphisms","title":"IntersectionTheory.hom","text":"hom(X::AbsVariety, Y::AbsVariety)\n\nReturn a canonicallly defined morphism from X to Y.\n\n\n\n","category":"method"},{"location":"morphisms/","page":"Morphisms","title":"Morphisms","text":"Using hom(X, Y) (or X → Y) without other arguments will try to find a canonically defined morphism from X to Y. This means","category":"page"},{"location":"morphisms/","page":"Morphisms","title":"Morphisms","text":"Either X or Y is a point;\nWhen X is a product of Y with some other variety, so we have a projection map;\nWhen X is a projective / relative flag bundle over Y (in other words, one can arrive at Y by following the chain of structure maps from X).","category":"page"},{"location":"morphisms/","page":"Morphisms","title":"Morphisms","text":"In Schubert2, this is the operator X / Y. We will however use the symbol X → Y instead, which can be typed using the LaTeX-like abbreviation X \\to[tab] Y.","category":"page"},{"location":"morphisms/#Examples-2","page":"Morphisms","title":"Examples","text":"","category":"section"},{"location":"morphisms/#Products","page":"Morphisms","title":"Products","text":"","category":"section"},{"location":"morphisms/","page":"Morphisms","title":"Morphisms","text":"P, Q = proj(1), proj(1)\nPxQ = P * Q\nPxQ → P","category":"page"},{"location":"morphisms/","page":"Morphisms","title":"Morphisms","text":"Note that if we use PxP = P * P, then we will only be able to get the first projection using PxP → P since we cannot distinguish the two components. Alternatively we can retrieve the two projections using get_special(PxQ, :projections) or PxQ.other[:projections].","category":"page"},{"location":"morphisms/","page":"Morphisms","title":"Morphisms","text":"PxQ.other[:projections]","category":"page"},{"location":"morphisms/#Structure-map","page":"Morphisms","title":"Structure map","text":"","category":"section"},{"location":"morphisms/","page":"Morphisms","title":"Morphisms","text":"X, (E,) = variety(2, [3 => \"c\"])\nPE = proj(E)\nPE → X","category":"page"},{"location":"morphisms/","page":"Morphisms","title":"Morphisms","text":"The structure maps are also used for coercion of bundles. For example, in the above case we can pullback bundles by tensoring with the structure sheaf of mathbf P(E).","category":"page"},{"location":"morphisms/","page":"Morphisms","title":"Morphisms","text":"OO(PE) * E","category":"page"},{"location":"morphisms/#Operators","page":"Morphisms","title":"Operators","text":"","category":"section"},{"location":"morphisms/","page":"Morphisms","title":"Morphisms","text":"pullback\npushforward\n*(f::AbsVarietyHom, g::AbsVarietyHom)\ndim(f::AbsVarietyHom)\ntangent_bundle(f::AbsVarietyHom)\ncotangent_bundle(f::AbsVarietyHom)\ntodd(f::AbsVarietyHom)","category":"page"},{"location":"morphisms/#IntersectionTheory.pullback","page":"Morphisms","title":"IntersectionTheory.pullback","text":"pullback(f::AbsVarietyHom, x::ChRingElem)\npullback(f::AbsVarietyHom, F::AbsBundle)\n\nCompute the pullback of a Chow ring element x or a bundle F by a morphism f.\n\n\n\n","category":"function"},{"location":"morphisms/#IntersectionTheory.pushforward","page":"Morphisms","title":"IntersectionTheory.pushforward","text":"pushforward(f::AbsVarietyHom, x::ChRingElem)\npushforward(f::AbsVarietyHom, F::AbsBundle)\n\nCompute the pushforward of a Chow ring element x or a bundle F by a morphism f. For abstract bundles, the pushforward is derived, e.g., for a bundle F it is understood as the alternating sum of all direct images.\n\n\n\n","category":"function"},{"location":"morphisms/#Base.:*-Tuple{IntersectionTheory.AbsVarietyHom, IntersectionTheory.AbsVarietyHom}","page":"Morphisms","title":"Base.:*","text":"*(f::AbsVarietyHom, g::AbsVarietyHom)\n\nConstruct the composition morphism gcirc f Xto Z for f Xto Y and gYto Z.\n\n\n\n","category":"method"},{"location":"morphisms/#AbstractAlgebra.Generic.dim-Tuple{IntersectionTheory.AbsVarietyHom}","page":"Morphisms","title":"AbstractAlgebra.Generic.dim","text":"dim(f::AbsVarietyHom)\n\nReturn the relative dimension.\n\n\n\n","category":"method"},{"location":"morphisms/#IntersectionTheory.tangent_bundle-Tuple{IntersectionTheory.AbsVarietyHom}","page":"Morphisms","title":"IntersectionTheory.tangent_bundle","text":"tangent_bundle(f::AbsVarietyHom)\n\nReturn the relative tangent bundle.\n\n\n\n","category":"method"},{"location":"morphisms/#IntersectionTheory.cotangent_bundle-Tuple{IntersectionTheory.AbsVarietyHom}","page":"Morphisms","title":"IntersectionTheory.cotangent_bundle","text":"cotangent_bundle(f::AbsVarietyHom)\n\nReturn the relative cotangent bundle.\n\n\n\n","category":"method"},{"location":"morphisms/#IntersectionTheory.todd-Tuple{IntersectionTheory.AbsVarietyHom}","page":"Morphisms","title":"IntersectionTheory.todd","text":"todd(f::AbsVarietyHom)\n\nCompute the Todd class of the relative tangent bundle.\n\n\n\n","category":"method"},{"location":"morphisms/#Blowup","page":"Morphisms","title":"Blowup","text":"","category":"section"},{"location":"morphisms/","page":"Morphisms","title":"Morphisms","text":"blowup","category":"page"},{"location":"morphisms/#IntersectionTheory.blowup","page":"Morphisms","title":"IntersectionTheory.blowup","text":"blowup(i::AbsVarietyHom)\n\nConstruct the blowup mathrmBl_XY of an inclusion iXhookrightarrow Y.\n\nReturn the variety mathrmBl and the exceptional divisor E.\n\n\n\n","category":"function"},{"location":"morphisms/","page":"Morphisms","title":"Morphisms","text":"Note that the exceptional divisor is returned as an abstract variety. To get its class in the blowup, we can use pushforward(E → Bl, E(1)).","category":"page"},{"location":"morphisms/#Examples-3","page":"Morphisms","title":"Examples","text":"","category":"section"},{"location":"morphisms/","page":"Morphisms","title":"Morphisms","text":"P = proj(2)\nBl, E = blowup(point() → P)\neuler(Bl)\ne = pushforward(E → Bl, E(1))\nintegral(e^2)","category":"page"},{"location":"morphisms/","page":"Morphisms","title":"Morphisms","text":"Here is the solution to Steiner's problem.","category":"page"},{"location":"morphisms/","page":"Morphisms","title":"Morphisms","text":"P2, P5 = proj(2), proj(5)\nv = hom(P2, P5, [2P2.O1]) # the Veronese embedding\nBl, E = blowup(v)\nh = pullback(Bl → P5, P5.O1)\ne = pushforward(E → Bl, E(1))\nintegral((6h - 2e)^5)","category":"page"}]
}
