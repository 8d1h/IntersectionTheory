# generic types
abstract type Bundle end
Base.parent(F::Bundle) = F.parent
rank(F::Bundle) = F.rank

abstract type Variety end
dim(X::Variety) = X.dim

abstract type VarietyHom end
domain(X::VarietyHom) = X.domain
codomain(X::VarietyHom) = X.codomain

Base.show(io::IO, F::Bundle) = print(io, "$(typeof(F).name.name) of rank $(F.rank) on $(F.parent)")
Base.show(io::IO, X::Variety) = print(io, "$(typeof(X).name.name) of dim $(X.dim)")
Base.show(io::IO, f::VarietyHom) = print(io, "$(typeof(f).name.name) from $(f.domain) to $(f.codomain)")

@doc Markdown.doc"""
    ChRing(R::MPolyRing, w::Vector{Int})
    ChRing(R::MPolyRing, w::Vector{Int}, I::sideal)
The type of a graded ring, possibly equipped with an ideal to represent a
quotient ring.
"""
mutable struct ChRing <: Ring
  R::MPolyRing
  w::Vector{Int}
  I::sideal
  @declare_other
  function ChRing(R::MPolyRing, w::Vector{Int}, opts::Pair...)
    R = new(R, w)
    for o in opts set_special(R, o) end
    return R
  end
  function ChRing(R::MPolyRing, w::Vector{Int}, I::sideal, opts::Pair...)
    I = std(I)
    R = new(R, w, I)
    for o in opts set_special(R, o) end
    return R
  end
end

function Base.show(io::IO, R::ChRing)
  print(io, "ambient ring: generated by $(tuple(gens(R)...)) with weight $(tuple(R.w...))")
  if isdefined(R, :I)
    print(io, "\nideal generated by: ")
    n = Singular.ngens(R.I)
    for i in 1:n - 1
      print(io, "$(R.I[i]), ")
    end
    print(io, "$(R.I[n])")
  end
  if base_ring(R.R) != Singular.QQ
    print(io, "\ncoefficient: $(base_ring(R.R))")
  end
end

# allow reduction
(R::ChRing)(f::RingElement; reduce::Bool=false) = begin
  if !(parent(f) == R.R) f = R.R(f) end
  if reduce && isdefined(R, :I) f = Singular.reduce(f, R.I) end
  ChRingElem(R, f)
end
(R::ChRing)() = R(0)
zero(R::ChRing) = R(0)
one(R::ChRing) = R(1)
gens(R::ChRing) = R.(gens(R.R))

@doc Markdown.doc"""
    ChRingElem(R::ChRing, f::RingElem)
The type of an element of a `ChRing`.
"""
mutable struct ChRingElem <: RingElem
  parent::ChRing
  f::RingElem
  @declare_other
  function ChRingElem(R::ChRing, f::RingElem)
    new(R, R.R(f))
  end
end

(R::ChRing)(x::ChRingElem) = R(x.f)
one(::Type{ChRingElem}) = 1
# mul!(a::ChRingElem, b::ChRingElem, c::ChRingElem) = (a.f = b.f * c.f; a)
# addeq!(a::ChRingElem, b::ChRingElem) = (a.f += b.f; a)

@doc Markdown.doc"""
    ChAlgHom(A::ChRing, B::ChRing, image::Vector)
The type of a ring homomorphism between two `ChRing`s.
"""
mutable struct ChAlgHom
  domain::ChRing
  codomain::ChRing
  image::Vector{ChRingElem}
  salg::Singular.SAlgHom
  function ChAlgHom(A::ChRing, B::ChRing, image::Vector{ChRingElem})
    salg = Singular.AlgebraHomomorphism(A.R, B.R, [x.f for x in image])
    new(A, B, image, salg)
  end
  function ChAlgHom(A::ChRing, B::ChRing, image::Vector)
    image = B.(image)
    ChAlgHom(A, B, image)
  end
end

function (f::ChAlgHom)(x::ChRingElem)
  @assert x.parent == f.domain
  f.codomain(f.salg(x.f), reduce=true)
end

function *(f::ChAlgHom, g::ChAlgHom)
  A, B = f.domain, f.codomain
  @assert B == g.domain
  C = g.codomain
  ChAlgHom(A, C, g.(f.image))
end

for (func, par) in [:obj_to_string => ["(", ")"],
		    :obj_to_latex_string => ["\\left(", "\\right)"]]
  @eval function AbstractAlgebra.$func(x::ChRingElem)
    x = simplify(x)
    iszero(x) && return "0"
    d = total_degree(x)
    comps = [c.f for c in x[0:d] if !iszero(c)]
    length(comps) == 1 && return AbstractAlgebra.$func(comps[1])
    str = string()
    plus = false
    for c in comps # print by homogeneous terms
      if plus
	str *= " + "
      else
	plus = true
      end
      if length(c) > 1 || first(string(c)) == '-' # needs parentheses
	str *= $par[1] * AbstractAlgebra.$func(c) * $par[2]
      else
	str *= AbstractAlgebra.$func(c)
      end
    end
    str
  end
end
Base.show(io::IO, x::ChRingElem) =
  print(io, AbstractAlgebra.obj_to_string(x))
Base.show(io::IO, mi::MIME"text/latex", x::ChRingElem) =
  print(io, AbstractAlgebra.obj_to_latex_string(x))
Base.show(io::IO, mi::MIME"text/html", x::ChRingElem) =
  print(io, "\$" * AbstractAlgebra.obj_to_latex_string(x) * "\$")

Nemo.elem_type(::Type{ChRing}) = ChRingElem

# for now _coerce does nothing
function _coerce(x::ChRingElem, y::ChRingElem)
  @assert x.parent == y.parent
  x, y
end

Base.parent(x::ChRingElem) = x.parent
Nemo.parent_type(::Type{ChRingElem}) = ChRing

-(x::ChRingElem) = x.parent(-x.f)
# reduction for `*` and `^` only
for (O, reduce) in [:(+) => false, :(-) => false, :(*) => true]
  @eval $O(x::ChRingElem, y::ChRingElem) = (
    (x, y) = _coerce(x, y);
    x.parent($O(x.f, y.f), reduce=$reduce))
  for T in [:Int, :Rational, :fmpz, :fmpq, :n_Q, :n_transExt, :RingElem]
    @eval $O(a::$T, x::ChRingElem) = (
      x.parent($O(a, x.f), reduce=$reduce))
    @eval $O(x::ChRingElem, a::$T) = (
      x.parent($O(x.f, a), reduce=$reduce))
  end
end
^(x::ChRingElem, n::Int) = x.parent(x.f^n, reduce=true)

for T in [:Int, :Rational, :fmpz, :fmpq, :n_Q, :n_transExt, :RingElem]
  @eval ==(a::$T, x::ChRingElem) = x.parent(a) == x
  @eval ==(x::ChRingElem, a::$T) = x.parent(a) == x
end
==(x::ChRingElem, y::ChRingElem) = (
  (x, y) = _coerce(x, y);
  R = x.parent;
  R(x.f, reduce=true).f == R(y.f, reduce=true).f)

function total_degree(x::ChRingElem)
  R = x.parent
  f = R(x.f, reduce=true).f
  f == 0 && return -1
  max([sum(R.w .* Singular.degrees(t)) for t in Singular.terms(f)]...)
end

function ishomogeneous(x::ChRingElem)
  R = x.parent
  f = R(x.f, reduce=true).f
  f == 0 && return true
  degs = [sum(R.w .* Singular.degrees(t)) for t in Singular.terms(f)]
  all(d -> d==degs[1], degs)
end

div(x::ChRingElem, y::ChRingElem) = (
  (x, y) = _coerce(x, y);
  R = x.parent;
  xf = R(x.f, reduce=true).f;
  yf = R(y.f, reduce=true).f;
  if yf == 0 throw(DivideError) end;
  R(div(xf, yf)))

function Base.getindex(x::ChRingElem, n::Int)
  R = x.parent
  d = get_special(R, :variety_dim)
  d !== nothing && n > d && return R(0)
  f = R(x.f, reduce=true).f
  ans = R(0)
  for t in Singular.terms(f)
    if sum(R.w .* Singular.degrees(t)) == n
      ans += t end
  end
  ans
end

function Base.getindex(x::ChRingElem, I::UnitRange)
  R = x.parent
  f = R(x.f, reduce=true).f
  ans = repeat([R(0)], length(I))
  d = get_special(R, :variety_dim)
  stop = (d === nothing) ? I.stop : min(I.stop, d)
  for t in Singular.terms(f)
    d = R.w' * Singular.degrees(t)
    if d ≥ I.start && d ≤ stop
      ans[d - I.start + 1] += t end
  end
  ans
end

function simplify(x::ChRingElem)
  R = x.parent
  n = get_special(R, :variety_dim)
  # no dimension restriction
  n === nothing && return R(x.f, reduce=true)
  # otherwise keep only terms in degree ≤ n
  n < 0 && return R.R()
  return sum(x[0:n])
end

simplify!(x::ChRingElem) = (x.f = simplify(x).f; x)

# add all the relations to a Chow ring due to dimension
function trim!(R::ChRing)
  d = get_special(R, :variety_dim)
  if isdefined(R, :I)
    gI = gens(R.I)
    # check that I is homogeneous, using the weights of R
    @assert all(g -> ishomogeneous(R(g)), gI)
  else
    gI = Singular.spoly[]
  end
  if !isdefined(R, :I) || Singular.dimension(R.I) > 0 
    # add powers of variables so that the ideal becomes 0-dimensional
    # below we will use kbase to further trim all the terms of degree > dim
    for (i,x) in enumerate(gens(R.R))
      push!(gI, x^Int(ceil((d+1)//R.w[i])))
    end
  end
  b = gens(Singular.kbase(std(Ideal(R.R, gI...))))
  R.I = std(Ideal(R.R, vcat(gI, filter(x -> total_degree(R(x)) > d, b))...))
  return R
end

function add_vars(R::ChRing, vars::Vector{Pair{Int, String}}; w::Vector{Int}=Int[], prod_ordering=false)
  base = base_ring(R.R)
  syms = vcat([_parse_symbol(s, 1:k) for (k,s) in vars]..., string.(gens(R.R)))
  n = sum(k for (k,_) in vars)
  if length(w) == 0 w = repeat([1], n) end
  @assert length(w) == n
  ord = prod_ordering ? ordering_dp(n) * R.R.ord : :degrevlex
  Rx, x = PolynomialRing(base, syms, ordering=ord)
  toRx = Singular.AlgebraHomomorphism(R.R, Rx, x[n+1:end])
  isdefined(R, :I) && return ChRing(Rx, vcat(w, R.w), Ideal(Rx, toRx.(gens(R.I))))
  return ChRing(Rx, vcat(w, R.w))
end

function add_rels!(R::ChRing, rels::Vector{Singular.spoly{T}}) where T
  @assert all(g -> parent(g) == R.R, rels)
  R.I = isdefined(R, :I) ? std(R.I + Ideal(R.R, rels)) : std(Ideal(R.R, rels))
  return R
end

function chow_ring(R::MPolyRing, w::Vector{Int}, rels::Vector{Singular.spoly{T}}) where T
  ChRing(R, w, Ideal(R, rels))
end

# copied from Oscar. I should really start migrating to Oscar...
abstract type GAPGroup <: AbstractAlgebra.Group end
abstract type GAPGroupElem{T<:GAPGroup} <: AbstractAlgebra.GroupElem end
struct BasicGAPGroupElem{T<:GAPGroup} <: GAPGroupElem{T}
  parent::T
  X::GapObj
end
Base.show(io::IO, x::GAPGroupElem) =  print(io, GAP.gap_to_julia(GAP.Globals.StringViewObj(x.X)))
Base.show(io::IO, x::GAPGroup) = print(io, GAP.gap_to_julia(GAP.Globals.StringViewObj(x.X)))
*(x::BasicGAPGroupElem, y::BasicGAPGroupElem) = (@assert x.parent == y.parent; BasicGAPGroupElem(x.parent, x.X * y.X))

function cyc(cycles::AbstractVector{T}...) where T <: Union{Base.Integer, fmpz}
  if cycles == Tuple([])
    cycles = [Int[]]
  end
  prod([GG.CycleFromList(GAP.julia_to_gap(Int.(c))) for c in cycles])
end

mutable struct WeylGroup <: GAPGroup
  X::GapObj
  gens::Vector{GapObj} # generators
  p::GapObj # the presentation
  typ::Char
  @declare_other
  function WeylGroup(str::String, I=nothing; implementation::Symbol=:perm)
    typ, n = str[1], parse(Int, str[2:end])
    # For type A, the permutation representation is meaningful: (i,i+1) is the
    # transposition of coordinates.
    # For type B,C,D, the permutation representation is simply faster than the
    # matrix representation, e.g., when using `StructureDescription`
    if typ in ['A', 'B', 'C', 'D'] && implementation == :perm
      if typ == 'A'
	gs = [cyc([i, i+1]) for i in 1:n]
      elseif typ == 'B' || typ == 'C'
	gs = push!([cyc([i, i+1], [n+i, n+i+1]) for i in 1:n-1], cyc([n, 2n]))
      elseif typ == 'D'
	gs = push!([cyc([i, i+1], [n+i, n+i+1]) for i in 1:n-2], cyc([n-1, n], [2n-1, 2n]), cyc([2n-1, n], [n-1, 2n]))
      end
    elseif typ in ['E', 'F', 'G'] || implementation == :matrix
      L = GG.SimpleLieAlgebra(GAP.julia_to_gap(string(typ)), n, GG.Rationals)
      gs = GG.GeneratorsOfGroup(GG.WeylGroup(GG.RootSystem(L)))
      gs = GAP.gap_to_julia(Vector{GapObj}, gs)
    else
      error("not implemented")
    end
    if I != nothing
      gs = [gs[i] for i in intersect(1:n, I)]
    end
    G = GG.Group(gs...)
    # WI = GG.Subgroup(G, GAP.julia_to_gap(GapObj[gs[i] for i in intersect(1:n, I)]))
    p = GG.EpimorphismFromFreeGroup(G)
    W = new(G, gs, p, typ)
    if typ == 'A'
      action = (w, f) -> (
	for i in _factor(w)
	  f = Singular.permute_variables(f, [j==i ? i+1 : j==i+1 ? i : j for j in 1:n+1], parent(f))
	end; f)
    elseif typ == 'B' || typ == 'C'
      action = (w, f) -> (
	for i in _factor(w)
	  if i < n
	    f = Singular.permute_variables(f, [j==i ? i+1 : j==i+1 ? i : j for j in 1:n], parent(f))
	  else
	    x = gens(parent(f))
	    f = f(x[1:end-1]..., -x[end])
	  end
	end; f)
    elseif typ == 'D'
      action = (w, f) -> (
	for i in _factor(w)
	  if i < n
	    f = Singular.permute_variables(f, [j==i ? i+1 : j==i+1 ? i : j for j in 1:n], parent(f))
	  else
	    x = gens(parent(f))
	    f = f(x[1:end-2]..., -x[end], -x[end-1])
	  end
	end; f)
    else
      action = nothing
    #   error("not implemented")
    end
    set_special(W, :action => action)
    return W
  end
end
function weyl_group(str::String, I=nothing; implementation::Symbol=:perm) WeylGroup(str, I, implementation=implementation) end

const WeylGroupElem = BasicGAPGroupElem{WeylGroup}

# XXX add check
(W::WeylGroup)(x::GapObj) = WeylGroupElem(W, x)
(W::WeylGroup)(cycs::AbstractVector{T}...) where T <: Union{Int, fmpz} = W(cyc(cycs...))
(W::WeylGroup)(p::AbstractAlgebra.Generic.Perm{T}) where T <: Union{Int, fmpz} = W(cyc([c for c in Nemo.cycles(p)]...))
# (W::WeylGroup)(x::PermGroupElem) = WeylGroupElem(W, x.X)
